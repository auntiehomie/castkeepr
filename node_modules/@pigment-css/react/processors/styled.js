'use strict';

var chunkXRFT6ZAT_js = require('./chunk-XRFT6ZAT.js');
var chunk2ZKSYVEZ_js = require('./chunk-2ZKSYVEZ.js');
var chunk5VRK3JMQ_js = require('./chunk-5VRK3JMQ.js');
var chunkIWNJMGWX_js = require('./chunk-IWNJMGWX.js');
var parser = require('@babel/parser');
var processorUtils = require('@wyw-in-js/processor-utils');
var shared = require('@wyw-in-js/shared');

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 

// src/utils/lowercaseFirstLetter.ts
var lowercaseFirstLetter = (string) => {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
};

// src/processors/styled.ts
var StyledProcessor = class extends chunkIWNJMGWX_js.BaseProcessor {
  constructor(params, ...args) {
    var _a;
    if (params.length <= 2) {
      throw chunkIWNJMGWX_js.BaseProcessor.SKIP;
    }
    super([params[0]], ...args);
    this.variableIdx = 0;
    this.finalVariants = [];
    this.overrides = {};
    this.counterMap = /* @__PURE__ */ new Map();
    this.baseClasses = [];
    this.collectedStyles = [];
    this.collectedVariables = [];
    this.collectedVariants = [];
    this.originalLocation = null;
    processorUtils.validateParams(
      params,
      ["callee", ["call", "member"], ["call", "template"]],
      `Invalid use of ${this.tagSource.imported} tag.`
    );
    const [callee, memberOrCall, styleCallOrTemplate] = params;
    const [callType, componentArg, componentMetaArg] = memberOrCall;
    const [, ...styleArgs] = styleCallOrTemplate;
    this.isTemplateTag = styleCallOrTemplate[0] === "template";
    this.componentMetaArg = componentMetaArg && componentMetaArg.kind === shared.ValueType.LAZY ? componentMetaArg : void 0;
    this.styleArgs = styleArgs;
    if (callType === "member") {
      this.component = componentArg;
    } else {
      switch (componentArg.kind) {
        case shared.ValueType.CONST:
          this.component = typeof componentArg.value === "string" ? componentArg.value : void 0;
          break;
        case shared.ValueType.LAZY:
          this.component = {
            node: componentArg.ex,
            source: componentArg.source
          };
          this.dependencies.push(componentArg);
          break;
        default:
          this.component = "FunctionalComponent";
          break;
      }
      if (componentMetaArg && componentMetaArg.kind !== shared.ValueType.FUNCTION) {
        this.dependencies.push(componentMetaArg);
      }
    }
    if (!this.component) {
      throw new Error("Invalid usage of `styled` tag");
    }
    styleArgs.flat().forEach((item) => {
      if ("kind" in item) {
        this.dependencies.push(item);
      }
    });
    if (callee[0] === "callee") {
      this.originalLocation = (_a = callee[1].loc) != null ? _a : null;
    }
  }
  getClassName(key = "base") {
    if (!this.counterMap.has(key)) {
      this.counterMap.set(key, 0);
    }
    const currentCount = this.counterMap.get(key);
    this.counterMap.set(key, currentCount + 1);
    return `${this.className}${key === "base" ? "" : `-${key}`}${currentCount > 0 ? `-${currentCount}` : ""}`;
  }
  generateArtifacts() {
    const artifacts = this.collectedStyles.map(([className, cssText]) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const rules = {
        [`.${className}`]: {
          className,
          cssText,
          displayName: this.displayName,
          start: (_b = (_a = this.location) == null ? void 0 : _a.start) != null ? _b : null
        }
      };
      const replacements = [
        {
          length: cssText.length,
          original: {
            start: {
              column: (_d = (_c = this.location) == null ? void 0 : _c.start.column) != null ? _d : 0,
              line: (_f = (_e = this.location) == null ? void 0 : _e.start.line) != null ? _f : 0
            },
            end: {
              column: (_h = (_g = this.location) == null ? void 0 : _g.end.column) != null ? _h : 0,
              line: (_j = (_i = this.location) == null ? void 0 : _i.end.line) != null ? _j : 0
            }
          }
        }
      ];
      return [rules, replacements];
    });
    artifacts.forEach((artifact) => {
      this.artifacts.push(["css", artifact]);
    });
  }
  buildTemplateTag(templateStrs, templateExpressions, values) {
    const cssClassName = chunk5VRK3JMQ_js.css(templateStrs, ...templateExpressions);
    const cssText = chunk5VRK3JMQ_js.cache.registered[cssClassName];
    const baseClass = this.getClassName();
    this.baseClasses.push(baseClass);
    this.collectedStyles.push([baseClass, cssText, null]);
    const variantsAccumulator = [];
    this.processOverrides(values, variantsAccumulator);
    variantsAccumulator.forEach((variant) => {
      this.processVariant(variant);
    });
    this.generateArtifacts();
  }
  /**
   * This handles transformation for direct tagged-template literal styled calls.
   *
   * @example
   * ```js
   * const Component = style('a')`
   *   color: red;
   * `;
   */
  buildForTemplateTag(values) {
    const templateStrs = [];
    templateStrs.raw = [];
    const templateExpressions = [];
    const { themeArgs } = this.options;
    this.styleArgs.flat().forEach((item) => {
      if ("kind" in item) {
        switch (item.kind) {
          case shared.ValueType.FUNCTION: {
            const value = values.get(item.ex.name);
            templateExpressions.push(value(themeArgs));
            break;
          }
          case shared.ValueType.CONST:
            templateExpressions.push(item.value);
            break;
          case shared.ValueType.LAZY: {
            const evaluatedValue = values.get(item.ex.name);
            if (typeof evaluatedValue === "function") {
              templateExpressions.push(evaluatedValue(themeArgs));
            } else {
              templateExpressions.push(evaluatedValue);
            }
            break;
          }
        }
      } else if (item.type === "TemplateElement") {
        templateStrs.push(item.value.cooked);
        templateStrs.raw.push(item.value.raw);
      }
    });
    this.buildTemplateTag(
      templateStrs,
      templateExpressions,
      values
    );
  }
  /**
   * This handles transformation for tagged-template literal styled calls that have already been
   * transformed through swc. See [styled-swc-transformed-tagged-string.input.js](../../tests/styled/fixtures/styled-swc-transformed-tagged-string.input.js)
   * for sample code.
   */
  buildForTransformedTemplateTag(values) {
    const [templateStrArg, ...restArgs] = this.styleArgs;
    const templateStrings = values.get(templateStrArg.ex.name);
    const templateStrs = [...templateStrings];
    templateStrs.raw = [...templateStrings];
    const templateExpressions = [];
    const { themeArgs } = this.options;
    restArgs.forEach((item) => {
      switch (item.kind) {
        case shared.ValueType.FUNCTION: {
          const value = values.get(item.ex.name);
          templateExpressions.push(value(themeArgs));
          break;
        }
        case shared.ValueType.LAZY: {
          const evaluatedValue = values.get(item.ex.name);
          if (typeof evaluatedValue === "function") {
            templateExpressions.push(evaluatedValue(themeArgs));
          } else {
            templateExpressions.push(evaluatedValue);
          }
          break;
        }
      }
    });
    this.buildTemplateTag(
      templateStrs,
      templateExpressions,
      values
    );
  }
  buildForStyledCall(values) {
    const themeImportIdentifier = this.astService.addDefaultImport(
      `${this.getImportPath()}/theme`,
      "theme"
    );
    let variantsAccumulator = [];
    this.styleArgs.forEach((styleArg) => {
      this.processStyle(values, styleArg, variantsAccumulator, themeImportIdentifier.name);
    });
    variantsAccumulator.forEach((variant) => {
      this.processVariant(variant);
    });
    variantsAccumulator = [];
    this.processOverrides(values, variantsAccumulator);
    variantsAccumulator.forEach((variant) => {
      this.processVariant(variant);
    });
    this.generateArtifacts();
  }
  /**
   * There are 2 main phases in Wyw-in-JS's processing, Evaltime and Runtime. During Evaltime, Wyw-in-JS prepares minimal code that gets evaluated to get the actual values of the styled arguments. Here, we mostly want to replace the styled calls with a simple string/object of its classname. This is necessary for class composition. For ex, you could potentially do this -
   * ```js
   * const Component = styled(...)(...)
   * const Component2 = styled()({
   *   [`${Component} &`]: {
   *      color: 'red'
   *   }
   * })
   * ```
   * to further target `Component` rendered inside `Component2`.
   */
  doEvaltimeReplacement() {
    this.replacer(this.astService.stringLiteral(this.asSelector), false);
  }
  isMaybeTransformedTemplateLiteral(values) {
    const [firstArg, ...restArgs] = this.styleArgs;
    if (!("kind" in firstArg) || firstArg.kind === shared.ValueType.CONST) {
      return false;
    }
    const firstArgVal = values.get(firstArg.ex.name);
    if (Array.isArray(firstArgVal) && restArgs.length === firstArgVal.length - 1) {
      return true;
    }
    return false;
  }
  /**
   * This is called by Wyw-in-JS after evaluating the code. Here, we
   * get access to the actual values of the `styled` arguments
   * which we can use to generate our styles.
   * Order of processing styles -
   * 1. CSS directly declared in styled call
   * 3. Variants declared in styled call
   * 2. CSS declared in theme object's styledOverrides
   * 3. Variants declared in theme object
   */
  build(values) {
    if (this.isTemplateTag) {
      this.buildForTemplateTag(values);
      return;
    }
    if (this.isMaybeTransformedTemplateLiteral(values)) {
      this.buildForTransformedTemplateTag(values);
      return;
    }
    this.buildForStyledCall(values);
  }
  /**
   * This is the runtime phase where all of the css have been transformed and we finally want to replace the `styled` call with the code that we want in the final bundle. In this particular case, we replace the `styled` calls with
   * ```js
   * const Component = styled('div')({
   *  displayName: 'Component',
   *  name: 'MuiSlider',
   *  slot: 'root',
   *  classes: ['class', 'class-1', '...'],
   *  vars: {
   *    'var-id': [(props) => props.isRed ? 'red' : 'blue', false],
   *    // ...
   *  },
   *  variants: [{
   *    props: {
   *    },
   *    className: 'class-variant-1',
   *  }],
   *  // ...
   * })
   * ```
   */
  doRuntimeReplacement() {
    var _a;
    const t = this.astService;
    let componentName;
    if (typeof this.component === "string") {
      if (this.component === "FunctionalComponent") {
        componentName = t.arrowFunctionExpression([], t.blockStatement([]));
      } else {
        componentName = t.stringLiteral(this.component);
      }
    } else if ((_a = this.component) == null ? void 0 : _a.node) {
      componentName = t.callExpression(t.identifier(this.component.node.name), []);
    } else {
      componentName = t.nullLiteral();
    }
    const argProperties = [];
    const classNames = Array.from(
      /* @__PURE__ */ new Set([this.className, ...this.baseClasses.length ? this.baseClasses : []])
    );
    argProperties.push(
      t.objectProperty(
        t.identifier("classes"),
        t.arrayExpression(classNames.map((cls) => t.stringLiteral(cls)))
      )
    );
    const varProperties = this.collectedVariables.map(
      ([variableId, expression, isUnitLess]) => t.objectProperty(
        t.stringLiteral(variableId),
        t.arrayExpression([expression, t.booleanLiteral(isUnitLess)])
      )
    );
    if (varProperties.length) {
      argProperties.push(t.objectProperty(t.identifier("vars"), t.objectExpression(varProperties)));
    }
    if (this.collectedVariants.length) {
      argProperties.push(
        t.objectProperty(t.identifier("variants"), chunkXRFT6ZAT_js.valueToLiteral(this.collectedVariants))
      );
    }
    let componentMetaExpression;
    if (this.componentMetaArg) {
      const parsedMeta = parser.parseExpression(this.componentMetaArg.source);
      if (parsedMeta.type === "ObjectExpression") {
        componentMetaExpression = parsedMeta;
      }
    }
    const styledImportIdentifier = t.addNamedImport("styled", this.getImportPath());
    const styledCall = t.callExpression(
      styledImportIdentifier,
      componentMetaExpression ? [componentName, componentMetaExpression] : [componentName]
    );
    const mainCall = t.callExpression(styledCall, [t.objectExpression(argProperties)]);
    this.replacer(mainCall, true);
  }
  /**
   * Generates css for object directly provided as arguments in the styled call.
   */
  processStyle(values, styleArg, variantsAccumulator, themeImportIdentifier) {
    if (styleArg.kind === shared.ValueType.CONST) {
      if (typeof styleArg.value === "string") {
        this.collectedStyles.push([this.getClassName(), styleArg.value, styleArg]);
      }
    } else {
      const styleObjOrFn = values.get(styleArg.ex.name);
      const finalStyle = this.processCss(
        styleObjOrFn,
        styleArg,
        variantsAccumulator,
        themeImportIdentifier
      );
      const className = this.getClassName();
      this.baseClasses.push(className);
      this.collectedStyles.push([className, finalStyle, styleArg]);
    }
  }
  /**
   * Generates css for styleOverride objects in the theme object.
   */
  processOverrides(values, variantsAccumulator) {
    var _a;
    if (!this.componentMetaArg) {
      return;
    }
    const value = values.get(this.componentMetaArg.ex.name);
    const { themeArgs: { theme } = {} } = this.options;
    if (!value.name || !value.slot || !theme) {
      return;
    }
    const componentData = (_a = theme.components) == null ? void 0 : _a[value.name];
    if (!componentData) {
      return;
    }
    if ("styleOverrides" in componentData) {
      const overrides = componentData.styleOverrides;
      if (!overrides) {
        return;
      }
      const overrideStyle = overrides[lowercaseFirstLetter(value.slot)] || overrides[value.slot];
      const className = this.getClassName();
      if (typeof overrideStyle === "string") {
        this.collectedStyles.push([className, overrideStyle, null]);
        return;
      }
      const finalStyle = this.processCss(overrideStyle, null, variantsAccumulator);
      this.baseClasses.push(className);
      this.collectedStyles.push([className, finalStyle, null]);
    }
    if (!variantsAccumulator) {
      return;
    }
    if ("variants" in componentData && componentData.variants && lowercaseFirstLetter(value.slot) === "root") {
      variantsAccumulator.push(...componentData.variants);
    }
  }
  /**
   * Generates css for all the variants collected after processing direct css and styleOverride css.
   */
  processVariant(variant) {
    const { displayName } = this.options;
    const className = this.getClassName(displayName ? "variant" : void 0);
    const styleObjOrFn = variant.style;
    const originalExpression = variant.originalExpression;
    const finalStyle = this.processCss(styleObjOrFn, originalExpression != null ? originalExpression : null);
    this.collectedStyles.push([className, finalStyle, null]);
    this.collectedVariants.push({
      props: variant.props,
      className
    });
  }
  processCss(styleObjOrFn, styleArg, variantsAccumulator, themeImportIdentifier) {
    const { themeArgs = {} } = this.options;
    let styleObj = typeof styleObjOrFn === "function" ? styleObjOrFn(themeArgs) : styleObjOrFn;
    if (!styleObj) {
      return "";
    }
    styleObj = chunkIWNJMGWX_js.__spreadValues({}, styleObj);
    if (styleObj.variants) {
      variantsAccumulator == null ? void 0 : variantsAccumulator.push(
        ...styleObj.variants.map((variant) => chunkIWNJMGWX_js.__spreadProps(chunkIWNJMGWX_js.__spreadValues({}, variant), {
          originalExpression: styleArg
        }))
      );
    }
    if (styleObj.isProcessed) {
      styleObj = styleObj.style;
    } else {
      delete styleObj.variants;
    }
    const res = chunk2ZKSYVEZ_js.cssFnValueToVariable({
      styleObj,
      expressionValue: styleArg,
      getVariableName: (cssKey, source, hasUnit) => this.getCustomVariableId(cssKey, source, hasUnit),
      filename: this.context.filename,
      options: this.options,
      includeThemeArg: typeof styleObjOrFn === "function",
      themeImportIdentifier
    });
    if (res.length) {
      this.collectedVariables.push(...res);
    }
    return chunk2ZKSYVEZ_js.processCssObject(styleObj, themeArgs);
  }
  get asSelector() {
    return `.${this.className}`;
  }
  get value() {
    const t = this.astService;
    return t.stringLiteral(this.className);
  }
};

exports.StyledProcessor = StyledProcessor;
//# sourceMappingURL=styled.js.map
//# sourceMappingURL=styled.js.map