import { Identifier, TemplateElement, Expression, SourceLocation } from '@babel/types';
import { IOptions as IOptions$1, Params, TailProcessorParams, ValueCache } from '@wyw-in-js/processor-utils';
import { LazyValue, ExpressionValue, ConstValue } from '@wyw-in-js/shared';
import { B as BaseProcessor } from './base-processor-FyHksda3.mjs';

type Theme = Record<string, any>;

type PluginCustomOptions = {
    /**
     * Object to pass as parameter to the styled css callback functions.
     */
    themeArgs?: {
        theme?: Theme;
    };
    /**
     * Customize the output CSS. Mainly used for RTL support right now.
     */
    css?: {
        /**
         * To denote that whatever default css is being authored pertains to this
         * direction so that when Pigment CSS generates the CSS for the other direction,
         * it can revert the direction of the selector accordingly.
         * @default 'ltr'
         */
        defaultDirection: 'ltr' | 'rtl';
        /**
         * Pass this as true if you want to output the CSS for both ltr and rtl.
         * The css of the non-default direction will be wrapped in a `dir` selector.
         */
        generateForBothDir: boolean;
        /**
         * Pass this callback to customize the selector for the `dir` attribute. The default
         * is [dir=ltr] or [dir=rtl].
         */
        getDirSelector?: (dir: 'ltr' | 'rtl') => string;
    };
    /**
     * Customize the replacement package name that should be added in-place of
     * the actually imported package name, ie,
     *
     * ```js
     * import { styled } from '@pigment-css/react';
     * ```
     *
     * will turn into
     *
     * ```js
     * import { styled } from '@mui/material-pigment-css';
     * ```
     *
     * if packageMap has this
     *
     * ```js
     * {
     *   packageMap: {
     *     '@pigment-css/react': '@mui/material-pigment-css',
     *   }
     * }
     * ```
     */
    packageMap?: Record<string, string>;
};

type VariantData = {
    props: (componentProps: unknown) => boolean | Record<string, string | number | boolean | null>;
    style: object;
    originalExpression?: Exclude<ExpressionValue, ConstValue>;
};
type VariantDataTransformed = {
    props: VariantData['props'];
    className: string;
};
type WrappedNode = string | {
    node: Identifier;
    nonLinaria?: true;
    source: string;
};
type IOptions = IOptions$1 & PluginCustomOptions;
/**
 * WyW-in-JS tag processor responsible for converting complex `styled()()` calls
 * at build-time to simple `styled` calls supported by runtime.
 *
 * Ex -
 * ```
 * const SliderTrack = styled('h4', {
 *   name: 'MuiSlider',
 *   slot: 'Track',
 *   overridesResolver: (props, styles) => styles.track,
 * })({
 *   fontSize: 13,
 *   color: (props) => (props.isRed ? 'red' : 'blue'),
 * });
 * ```
 *
 * gets converted to a simple styled call with no nested calls -
 *
 * ```
 * const SliderTrack = styled('h4', {
 *   classes: ['h13ydq1s'],
 *   vars: { 'b1xyu9xj-0': [(t) => (t.isRed ? 'red' : 'blue'), !1] },
 *   variants: [],
 *   name: 'MuiSlider',
 *   slot: 'Track',
 *   overridesResolver: (t, o) => o.track,
 *   overrideStyles: {}
 * })
 * ```
 *
 * and this css
 * ```css
 * .h13ydq1s {
 *   fontSize: 13px,
 *   color: var(--b1xyu9xj-0);
 * }
 * ```
 *
 * For Wyw-in-JS tag processors, we need to implement 3 methods of BaseProcessor -
 * 1. doEvaltimeReplacement
 * 2. build
 * 3. doRuntimeReplacement
 */
declare class StyledProcessor extends BaseProcessor {
    variableIdx: number;
    component?: WrappedNode;
    componentMetaArg?: LazyValue;
    styleArgs: ExpressionValue[] | (TemplateElement | ExpressionValue)[];
    finalVariants: {
        props: Record<string, string | number | boolean | null>;
        className: string;
    }[];
    overrides: Record<string, string>;
    counterMap: Map<string, number>;
    baseClasses: string[];
    collectedStyles: [string, string, ExpressionValue | null][];
    collectedVariables: [string, Expression, boolean][];
    collectedVariants: VariantDataTransformed[];
    originalLocation: SourceLocation | null;
    isTemplateTag: boolean;
    constructor(params: Params, ...args: TailProcessorParams);
    getClassName(key?: string): string;
    private generateArtifacts;
    private buildTemplateTag;
    /**
     * This handles transformation for direct tagged-template literal styled calls.
     *
     * @example
     * ```js
     * const Component = style('a')`
     *   color: red;
     * `;
     */
    private buildForTemplateTag;
    /**
     * This handles transformation for tagged-template literal styled calls that have already been
     * transformed through swc. See [styled-swc-transformed-tagged-string.input.js](../../tests/styled/fixtures/styled-swc-transformed-tagged-string.input.js)
     * for sample code.
     */
    private buildForTransformedTemplateTag;
    private buildForStyledCall;
    /**
     * There are 2 main phases in Wyw-in-JS's processing, Evaltime and Runtime. During Evaltime, Wyw-in-JS prepares minimal code that gets evaluated to get the actual values of the styled arguments. Here, we mostly want to replace the styled calls with a simple string/object of its classname. This is necessary for class composition. For ex, you could potentially do this -
     * ```js
     * const Component = styled(...)(...)
     * const Component2 = styled()({
     *   [`${Component} &`]: {
     *      color: 'red'
     *   }
     * })
     * ```
     * to further target `Component` rendered inside `Component2`.
     */
    doEvaltimeReplacement(): void;
    isMaybeTransformedTemplateLiteral(values: ValueCache): boolean;
    /**
     * This is called by Wyw-in-JS after evaluating the code. Here, we
     * get access to the actual values of the `styled` arguments
     * which we can use to generate our styles.
     * Order of processing styles -
     * 1. CSS directly declared in styled call
     * 3. Variants declared in styled call
     * 2. CSS declared in theme object's styledOverrides
     * 3. Variants declared in theme object
     */
    build(values: ValueCache): void;
    /**
     * This is the runtime phase where all of the css have been transformed and we finally want to replace the `styled` call with the code that we want in the final bundle. In this particular case, we replace the `styled` calls with
     * ```js
     * const Component = styled('div')({
     *  displayName: 'Component',
     *  name: 'MuiSlider',
     *  slot: 'root',
     *  classes: ['class', 'class-1', '...'],
     *  vars: {
     *    'var-id': [(props) => props.isRed ? 'red' : 'blue', false],
     *    // ...
     *  },
     *  variants: [{
     *    props: {
     *    },
     *    className: 'class-variant-1',
     *  }],
     *  // ...
     * })
     * ```
     */
    doRuntimeReplacement(): void;
    /**
     * Generates css for object directly provided as arguments in the styled call.
     */
    processStyle(values: ValueCache, styleArg: ExpressionValue, variantsAccumulator?: VariantData[], themeImportIdentifier?: string): void;
    /**
     * Generates css for styleOverride objects in the theme object.
     */
    processOverrides(values: ValueCache, variantsAccumulator?: VariantData[]): void;
    /**
     * Generates css for all the variants collected after processing direct css and styleOverride css.
     */
    processVariant(variant: VariantData): void;
    processCss(styleObjOrFn: ((args: Record<string, unknown>) => void) | object, styleArg: ExpressionValue | null, variantsAccumulator?: VariantData[], themeImportIdentifier?: string): string;
    get asSelector(): string;
    get value(): Expression;
}

export { type IOptions, StyledProcessor, type WrappedNode };
