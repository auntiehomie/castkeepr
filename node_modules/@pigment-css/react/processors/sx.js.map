{"version":3,"sources":["../src/utils/spreadSxProp.ts","../src/processors/sx.ts"],"names":["astService","BaseProcessor","validateParams","ValueType","cssFnValueToVariable","processCssObject"],"mappings":"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","file":"sx.js","sourcesContent":["import { NodePath, types as astService } from '@babel/core';\nimport {\n  ArrayExpression,\n  CallExpression,\n  Expression,\n  JSXAttribute,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  ObjectExpression,\n  ObjectMethod,\n  ObjectProperty,\n  SpreadElement,\n} from '@babel/types';\n\nfunction isSxProp(path: NodePath) {\n  if (path.isJSXAttribute() && path.node.name.name === 'sx') {\n    return true;\n  }\n  if (\n    path.isObjectProperty() &&\n    path.node.key.type === 'Identifier' &&\n    path.node.key.name === 'sx'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction isSpreadExpression(path: NodePath) {\n  return path.isSpreadElement() || path.isJSXSpreadAttribute();\n}\n\nfunction getProps(paths: NodePath[]) {\n  const props: Array<SpreadElement | ObjectProperty> = [];\n  let sxPath: undefined | NodePath<JSXAttribute> | NodePath<ObjectProperty>;\n  paths.forEach((attr) => {\n    if (isSxProp(attr)) {\n      sxPath = attr as NodePath<JSXAttribute> | NodePath<ObjectProperty>;\n    } else if (isSpreadExpression(attr)) {\n      let containRuntimeSx = false;\n      attr.traverse({\n        CallExpression(path) {\n          const callee = path.get('callee');\n          if (callee.isIdentifier() && callee.node.name.startsWith('_sx')) {\n            containRuntimeSx = true;\n          }\n        },\n      });\n      if (!containRuntimeSx) {\n        props.push(\n          astService.spreadElement(\n            (attr as NodePath<JSXSpreadAttribute | SpreadElement>).node.argument,\n          ),\n        );\n      }\n    } else if (\n      attr.isJSXAttribute() &&\n      (attr.node.name.name === 'className' || attr.node.name.name === 'style')\n    ) {\n      const value = attr.get('value');\n      if (value.isJSXExpressionContainer()) {\n        props.push(\n          astService.objectProperty(\n            astService.identifier(attr.node.name.name),\n            value.get('expression').node as any,\n          ),\n        );\n      } else {\n        props.push(\n          astService.objectProperty(\n            astService.identifier(attr.node.name.name),\n            attr.node.value as any,\n          ),\n        );\n      }\n    } else if (\n      attr.isObjectProperty() &&\n      attr.node.key.type === 'Identifier' &&\n      (attr.node.key.name === 'className' || attr.node.key.name === 'style')\n    ) {\n      props.push(\n        astService.objectProperty(\n          astService.identifier(attr.node.key.name),\n          attr.node.value as any,\n        ),\n      );\n    }\n  });\n  return { props, sxPath };\n}\n\n/**\n * Convert the sx prop that contains the sx() call to runtime {...sx()} spread.\n *\n * It will try to find the sibling `className` and `style` props and put them in the second argument of\n * the runtime sx call.\n */\nexport default function spreadSxProp(tagPath: NodePath<CallExpression>) {\n  const target = tagPath.findParent((p) => p.isJSXOpeningElement() || p.isObjectExpression()) as\n    | NodePath<JSXOpeningElement>\n    | NodePath<ObjectExpression>\n    | null;\n  if (!target) {\n    return false;\n  }\n  let paths:\n    | NodePath<JSXAttribute | JSXSpreadAttribute>[]\n    | NodePath<ObjectProperty | SpreadElement | ObjectMethod>[] = [];\n  if (target.isJSXOpeningElement()) {\n    paths = target.get('attributes');\n  }\n  if (target.isObjectExpression()) {\n    paths = target.get('properties');\n  }\n  const { props, sxPath } = getProps(paths);\n  let spreadSxNode: undefined | SpreadElement | JSXSpreadAttribute;\n  if (sxPath) {\n    const expression = sxPath.get('value');\n    if ('node' in expression) {\n      if (target.isObjectExpression()) {\n        spreadSxNode = astService.spreadElement(expression.node as Expression);\n        target.node.properties.push(spreadSxNode);\n      }\n      if (target.isJSXOpeningElement() && expression.isJSXExpressionContainer()) {\n        spreadSxNode = astService.jsxSpreadAttribute(expression.node.expression as Expression);\n        target.node.attributes.push(spreadSxNode);\n      }\n    }\n    sxPath.remove();\n  }\n  tagPath.node.arguments.push(astService.objectExpression(props));\n\n  if (spreadSxNode?.argument.type === 'ArrayExpression') {\n    spreadSxNode.argument = astService.callExpression(tagPath.node.callee, [\n      spreadSxNode.argument,\n      astService.objectExpression(props),\n    ]);\n  }\n\n  // This step is required to pass information about the array argument to the outer function\n  // to replace the `tagPath` with its first argument.\n  //\n  // Check if the sx value is an array expression\n  let arrayPath: NodePath<ArrayExpression> | null = null;\n  if (tagPath.parentPath.isArrayExpression()) {\n    // sx call is a direct child, e.g. [_sx(...), _sx(...)]\n    arrayPath = tagPath.parentPath;\n  } else if (tagPath.parentPath.parentPath?.isArrayExpression()) {\n    // sx call inside a conditional/logical expression, e.g. [true ? _sx(...) : _sx(...), prop && _sx(...)]\n    arrayPath = tagPath.parentPath.parentPath;\n  }\n  if (arrayPath) {\n    return true;\n  }\n\n  return false;\n}\n","import type { NodePath } from '@babel/core';\nimport type { CallExpression, Expression } from '@babel/types';\nimport {\n  validateParams,\n  type Params,\n  type TailProcessorParams,\n  type ValueCache,\n} from '@wyw-in-js/processor-utils';\nimport { ValueType, type ExpressionValue, type Replacements, type Rules } from '@wyw-in-js/shared';\nimport type { IOptions } from './styled';\nimport { processCssObject } from '../utils/processCssObject';\nimport { cssFnValueToVariable } from '../utils/cssFnValueToVariable';\nimport BaseProcessor from './base-processor';\nimport spreadSxProp from '../utils/spreadSxProp';\n\nexport class SxProcessor extends BaseProcessor {\n  sxArguments: ExpressionValue[] = [];\n\n  variableIdx: number = 0;\n\n  collectedVariables: [string, Expression, boolean][] = [];\n\n  elementClassName = '';\n\n  constructor(params: Params, ...args: TailProcessorParams) {\n    super([params[0]], ...args);\n    validateParams(params, ['callee', 'call'], 'Invalid usage of sx call.');\n    const [, [, ...sxCallArguments]] = params;\n    sxCallArguments.forEach((arg) => {\n      if ('kind' in arg) {\n        this.dependencies.push(arg);\n      }\n    });\n    this.sxArguments = sxCallArguments;\n  }\n\n  build(values: ValueCache) {\n    const [sxStyle, elementClassExpression] = this.sxArguments;\n    if (elementClassExpression.kind === ValueType.LAZY) {\n      const elementClassValue = values.get(elementClassExpression.ex.name);\n      if (typeof elementClassValue === 'string') {\n        this.elementClassName = elementClassValue;\n      }\n    }\n\n    let cssText: string = '';\n    if (sxStyle.kind === ValueType.CONST) {\n      if (sxStyle.ex.type === 'StringLiteral') {\n        cssText = sxStyle.ex.value;\n      }\n    } else {\n      const styleObjOrFn = values.get(sxStyle.ex.name);\n      cssText = this.processCss(styleObjOrFn, sxStyle);\n    }\n\n    if (!cssText) {\n      return;\n    }\n\n    const rules: Rules = {\n      [this.asSelector]: {\n        className: this.className,\n        cssText,\n        displayName: this.displayName,\n        start: this.location?.start ?? null,\n      },\n    };\n    const replacements: Replacements = [\n      {\n        length: cssText.length,\n        original: {\n          start: {\n            column: this.location?.start.column ?? 0,\n            line: this.location?.start.line ?? 0,\n          },\n          end: {\n            column: this.location?.end.column ?? 0,\n            line: this.location?.end.line ?? 0,\n          },\n        },\n      },\n    ];\n    this.artifacts.push(['css', [rules, replacements]]);\n  }\n\n  doEvaltimeReplacement() {\n    this.replacer(this.value, false);\n  }\n\n  doRuntimeReplacement() {\n    const t = this.astService;\n    // do not replace if sx prop is not a Pigment styled component\n    if (this.artifacts.length === 0) {\n      return;\n    }\n    let result = this.value;\n    if (this.collectedVariables.length) {\n      const varProperties: ReturnType<typeof t.objectProperty>[] = this.collectedVariables.map(\n        ([variableId, expression, isUnitLess]) => {\n          switch (expression.type) {\n            case 'ArrowFunctionExpression': {\n              const fnBody = expression.body as Expression;\n              // try to deserialize AST if possible\n              if (fnBody.type === 'StringLiteral') {\n                try {\n                  const body = JSON.parse(fnBody.value);\n                  return t.objectProperty(t.stringLiteral(variableId), body);\n                } catch (ex) {\n                  // proceed as usual\n                }\n              }\n              return t.objectProperty(\n                t.stringLiteral(variableId),\n                t.arrayExpression([expression.body as Expression, t.booleanLiteral(isUnitLess)]),\n              );\n            }\n            case 'FunctionExpression': {\n              const returnStatement = expression.body.body[0];\n              if (returnStatement.type === 'ReturnStatement' && returnStatement.argument) {\n                return t.objectProperty(\n                  t.stringLiteral(variableId),\n                  t.arrayExpression([returnStatement.argument, t.booleanLiteral(isUnitLess)]),\n                );\n              }\n              throw this.sxArguments[0].buildCodeFrameError(\n                'Invalid transformation encountered. The callbacks in sx properties should directly return an Expression.',\n              );\n            }\n            default: {\n              return t.objectProperty(t.stringLiteral(variableId), t.nullLiteral());\n            }\n          }\n        },\n      );\n\n      const obj = t.objectExpression([\n        t.objectProperty(t.identifier('className'), t.stringLiteral(this.className)),\n        t.objectProperty(t.identifier('vars'), t.objectExpression(varProperties)),\n      ]);\n      result = obj;\n    }\n\n    /**\n     * Replace the sx call with the transformed result. It works for both JSX and non-JSX calls.\n     *\n     * For example:\n     * <Component sx={_sx({ color: 'red' })} /> to <Component sx={_sx('sd5jss7')} />\n     * <Component sx={_sx({ bgcolor: 'red', color: props.color })} /> to <Component sx={_sx({ className: 'bc1d15y', vars: { 'bc1d15y-0': [props.color, false], }})} />\n     */\n    this.replacer((_tagPath) => {\n      const tagPath = _tagPath as NodePath<CallExpression>;\n      return t.callExpression(tagPath.get('callee').node, [result]);\n    }, false);\n\n    /**\n     * Replace the sx prop with runtime sx\n     */\n    let pathToReplace: undefined | NodePath<CallExpression>;\n    this.replacer((_tagPath) => {\n      const tagPath = _tagPath as NodePath<CallExpression>;\n\n      const isArrayArgument = spreadSxProp(tagPath);\n      if (isArrayArgument) {\n        pathToReplace = tagPath;\n      }\n\n      return tagPath.node;\n    }, false);\n\n    if (pathToReplace) {\n      // need to replace outside of `this.replacer` to preserve the import statement\n      pathToReplace.replaceWith(pathToReplace.node.arguments[0]);\n    }\n  }\n\n  get asSelector(): string {\n    return `.${this.className}`;\n  }\n\n  get value(): Expression {\n    return this.astService.stringLiteral(this.className);\n  }\n\n  private processCss(styleObjOrFn: unknown, expressionValue: ExpressionValue) {\n    const { themeArgs } = this.options as IOptions;\n    const styleObj =\n      typeof styleObjOrFn === 'function' ? styleObjOrFn(themeArgs?.theme) : styleObjOrFn;\n\n    const res = cssFnValueToVariable({\n      styleObj,\n      expressionValue,\n      getVariableName: (cssKey: string, source: string, hasUnit: boolean) =>\n        this.getCustomVariableId(cssKey, source, hasUnit),\n      filename: this.context.filename,\n      options: this.options as IOptions,\n    });\n    if (res.length) {\n      this.collectedVariables.push(...res);\n    }\n\n    return processCssObject(styleObj, themeArgs, false);\n  }\n}\n"]}