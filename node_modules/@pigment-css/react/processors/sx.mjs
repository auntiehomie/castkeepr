import { cssFnValueToVariable, processCssObject } from './chunk-DH2YTSGT.mjs';
import './chunk-C45XP3YA.mjs';
import { BaseProcessor } from './chunk-S2BUG7Y4.mjs';
import { validateParams } from '@wyw-in-js/processor-utils';
import { ValueType } from '@wyw-in-js/shared';
import { types } from '@babel/core';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
function isSxProp(path) {
  if (path.isJSXAttribute() && path.node.name.name === "sx") {
    return true;
  }
  if (path.isObjectProperty() && path.node.key.type === "Identifier" && path.node.key.name === "sx") {
    return true;
  }
  return false;
}
function isSpreadExpression(path) {
  return path.isSpreadElement() || path.isJSXSpreadAttribute();
}
function getProps(paths) {
  const props = [];
  let sxPath;
  paths.forEach((attr) => {
    if (isSxProp(attr)) {
      sxPath = attr;
    } else if (isSpreadExpression(attr)) {
      let containRuntimeSx = false;
      attr.traverse({
        CallExpression(path) {
          const callee = path.get("callee");
          if (callee.isIdentifier() && callee.node.name.startsWith("_sx")) {
            containRuntimeSx = true;
          }
        }
      });
      if (!containRuntimeSx) {
        props.push(
          types.spreadElement(
            attr.node.argument
          )
        );
      }
    } else if (attr.isJSXAttribute() && (attr.node.name.name === "className" || attr.node.name.name === "style")) {
      const value = attr.get("value");
      if (value.isJSXExpressionContainer()) {
        props.push(
          types.objectProperty(
            types.identifier(attr.node.name.name),
            value.get("expression").node
          )
        );
      } else {
        props.push(
          types.objectProperty(
            types.identifier(attr.node.name.name),
            attr.node.value
          )
        );
      }
    } else if (attr.isObjectProperty() && attr.node.key.type === "Identifier" && (attr.node.key.name === "className" || attr.node.key.name === "style")) {
      props.push(
        types.objectProperty(
          types.identifier(attr.node.key.name),
          attr.node.value
        )
      );
    }
  });
  return { props, sxPath };
}
function spreadSxProp(tagPath) {
  var _a;
  const target = tagPath.findParent((p) => p.isJSXOpeningElement() || p.isObjectExpression());
  if (!target) {
    return false;
  }
  let paths = [];
  if (target.isJSXOpeningElement()) {
    paths = target.get("attributes");
  }
  if (target.isObjectExpression()) {
    paths = target.get("properties");
  }
  const { props, sxPath } = getProps(paths);
  let spreadSxNode;
  if (sxPath) {
    const expression = sxPath.get("value");
    if ("node" in expression) {
      if (target.isObjectExpression()) {
        spreadSxNode = types.spreadElement(expression.node);
        target.node.properties.push(spreadSxNode);
      }
      if (target.isJSXOpeningElement() && expression.isJSXExpressionContainer()) {
        spreadSxNode = types.jsxSpreadAttribute(expression.node.expression);
        target.node.attributes.push(spreadSxNode);
      }
    }
    sxPath.remove();
  }
  tagPath.node.arguments.push(types.objectExpression(props));
  if ((spreadSxNode == null ? void 0 : spreadSxNode.argument.type) === "ArrayExpression") {
    spreadSxNode.argument = types.callExpression(tagPath.node.callee, [
      spreadSxNode.argument,
      types.objectExpression(props)
    ]);
  }
  let arrayPath = null;
  if (tagPath.parentPath.isArrayExpression()) {
    arrayPath = tagPath.parentPath;
  } else if ((_a = tagPath.parentPath.parentPath) == null ? void 0 : _a.isArrayExpression()) {
    arrayPath = tagPath.parentPath.parentPath;
  }
  if (arrayPath) {
    return true;
  }
  return false;
}

// src/processors/sx.ts
var SxProcessor = class extends BaseProcessor {
  constructor(params, ...args) {
    super([params[0]], ...args);
    this.sxArguments = [];
    this.variableIdx = 0;
    this.collectedVariables = [];
    this.elementClassName = "";
    validateParams(params, ["callee", "call"], "Invalid usage of sx call.");
    const [, [, ...sxCallArguments]] = params;
    sxCallArguments.forEach((arg) => {
      if ("kind" in arg) {
        this.dependencies.push(arg);
      }
    });
    this.sxArguments = sxCallArguments;
  }
  build(values) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const [sxStyle, elementClassExpression] = this.sxArguments;
    if (elementClassExpression.kind === ValueType.LAZY) {
      const elementClassValue = values.get(elementClassExpression.ex.name);
      if (typeof elementClassValue === "string") {
        this.elementClassName = elementClassValue;
      }
    }
    let cssText = "";
    if (sxStyle.kind === ValueType.CONST) {
      if (sxStyle.ex.type === "StringLiteral") {
        cssText = sxStyle.ex.value;
      }
    } else {
      const styleObjOrFn = values.get(sxStyle.ex.name);
      cssText = this.processCss(styleObjOrFn, sxStyle);
    }
    if (!cssText) {
      return;
    }
    const rules = {
      [this.asSelector]: {
        className: this.className,
        cssText,
        displayName: this.displayName,
        start: (_b = (_a = this.location) == null ? void 0 : _a.start) != null ? _b : null
      }
    };
    const replacements = [
      {
        length: cssText.length,
        original: {
          start: {
            column: (_d = (_c = this.location) == null ? void 0 : _c.start.column) != null ? _d : 0,
            line: (_f = (_e = this.location) == null ? void 0 : _e.start.line) != null ? _f : 0
          },
          end: {
            column: (_h = (_g = this.location) == null ? void 0 : _g.end.column) != null ? _h : 0,
            line: (_j = (_i = this.location) == null ? void 0 : _i.end.line) != null ? _j : 0
          }
        }
      }
    ];
    this.artifacts.push(["css", [rules, replacements]]);
  }
  doEvaltimeReplacement() {
    this.replacer(this.value, false);
  }
  doRuntimeReplacement() {
    const t = this.astService;
    if (this.artifacts.length === 0) {
      return;
    }
    let result = this.value;
    if (this.collectedVariables.length) {
      const varProperties = this.collectedVariables.map(
        ([variableId, expression, isUnitLess]) => {
          switch (expression.type) {
            case "ArrowFunctionExpression": {
              const fnBody = expression.body;
              if (fnBody.type === "StringLiteral") {
                try {
                  const body = JSON.parse(fnBody.value);
                  return t.objectProperty(t.stringLiteral(variableId), body);
                } catch (ex) {
                }
              }
              return t.objectProperty(
                t.stringLiteral(variableId),
                t.arrayExpression([expression.body, t.booleanLiteral(isUnitLess)])
              );
            }
            case "FunctionExpression": {
              const returnStatement = expression.body.body[0];
              if (returnStatement.type === "ReturnStatement" && returnStatement.argument) {
                return t.objectProperty(
                  t.stringLiteral(variableId),
                  t.arrayExpression([returnStatement.argument, t.booleanLiteral(isUnitLess)])
                );
              }
              throw this.sxArguments[0].buildCodeFrameError(
                "Invalid transformation encountered. The callbacks in sx properties should directly return an Expression."
              );
            }
            default: {
              return t.objectProperty(t.stringLiteral(variableId), t.nullLiteral());
            }
          }
        }
      );
      const obj = t.objectExpression([
        t.objectProperty(t.identifier("className"), t.stringLiteral(this.className)),
        t.objectProperty(t.identifier("vars"), t.objectExpression(varProperties))
      ]);
      result = obj;
    }
    this.replacer((_tagPath) => {
      const tagPath = _tagPath;
      return t.callExpression(tagPath.get("callee").node, [result]);
    }, false);
    let pathToReplace;
    this.replacer((_tagPath) => {
      const tagPath = _tagPath;
      const isArrayArgument = spreadSxProp(tagPath);
      if (isArrayArgument) {
        pathToReplace = tagPath;
      }
      return tagPath.node;
    }, false);
    if (pathToReplace) {
      pathToReplace.replaceWith(pathToReplace.node.arguments[0]);
    }
  }
  get asSelector() {
    return `.${this.className}`;
  }
  get value() {
    return this.astService.stringLiteral(this.className);
  }
  processCss(styleObjOrFn, expressionValue) {
    const { themeArgs } = this.options;
    const styleObj = typeof styleObjOrFn === "function" ? styleObjOrFn(themeArgs == null ? void 0 : themeArgs.theme) : styleObjOrFn;
    const res = cssFnValueToVariable({
      styleObj,
      expressionValue,
      getVariableName: (cssKey, source, hasUnit) => this.getCustomVariableId(cssKey, source, hasUnit),
      filename: this.context.filename,
      options: this.options
    });
    if (res.length) {
      this.collectedVariables.push(...res);
    }
    return processCssObject(styleObj, themeArgs, false);
  }
};

export { SxProcessor };
//# sourceMappingURL=sx.mjs.map
//# sourceMappingURL=sx.mjs.map