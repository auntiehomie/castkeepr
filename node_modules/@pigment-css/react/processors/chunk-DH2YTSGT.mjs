import { css, cache } from './chunk-C45XP3YA.mjs';
import { transformSync } from '@babel/core';
import { parseExpression } from '@babel/parser';
import * as t from '@babel/types';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 

// src/utils/isUnitLess.ts
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function isUnitLess(cssKey) {
  return unitlessKeys[cssKey] === 1 || cssKey.startsWith("--");
}

// src/utils/cssFnValueToVariable.ts
function parseAndWrapExpression(functionString, expressionValue, themeImportIdentifier) {
  if (!expressionValue) {
    return parseExpression(functionString);
  }
  const expression = parseExpression(functionString);
  if (expression.type === "FunctionExpression" || expression.type === "ArrowFunctionExpression") {
    expression.params.push(
      t.assignmentPattern(t.identifier("theme"), t.identifier(themeImportIdentifier != null ? themeImportIdentifier : "theme"))
    );
  }
  return expression;
}
function transformThemeKeysInFn(functionString, options, filename, expressionValue, themeImportIdentifier) {
  var _a;
  const { themeArgs: { theme } = {} } = options;
  if (!theme) {
    return parseAndWrapExpression(functionString, expressionValue, themeImportIdentifier);
  }
  const result = transformSync(functionString, {
    filename: filename != null ? filename : "intermediate-fn.ts",
    ast: true,
    configFile: false,
    babelrc: false
  });
  const firstItem = (_a = result == null ? void 0 : result.ast) == null ? void 0 : _a.program.body[0];
  if (!firstItem) {
    return parseAndWrapExpression(functionString, expressionValue, themeImportIdentifier);
  }
  const defaultThemeParam = t.assignmentPattern(
    t.identifier("theme"),
    t.identifier(themeImportIdentifier != null ? themeImportIdentifier : "theme")
  );
  if (firstItem.type === "ExpressionStatement") {
    const { expression } = firstItem;
    if (expression.type === "ArrowFunctionExpression" || expression.type === "FunctionExpression") {
      expression.params.push(defaultThemeParam);
    }
    return expression;
  }
  if (firstItem.type === "FunctionDeclaration") {
    return t.functionExpression(null, [...firstItem.params, defaultThemeParam], firstItem.body);
  }
  return parseAndWrapExpression(functionString, expressionValue, themeImportIdentifier);
}
function iterateAndReplaceFunctions(styleObj, expressionValue, getVariableName, options, acc, filename, themeImportIdentifier, includeThemeArg = false) {
  const css2 = styleObj;
  if (!css2) {
    return;
  }
  Object.keys(css2).forEach((key) => {
    const value = css2[key];
    if (value && typeof value === "object") {
      if (!Array.isArray(value)) {
        iterateAndReplaceFunctions(
          value,
          expressionValue,
          getVariableName,
          options,
          acc,
          filename,
          themeImportIdentifier,
          includeThemeArg
        );
      }
      return;
    }
    if (typeof value !== "function") {
      return;
    }
    try {
      const fnString = value.toString();
      const expression = transformThemeKeysInFn(
        fnString,
        options,
        filename,
        includeThemeArg && expressionValue ? expressionValue : void 0,
        themeImportIdentifier
      );
      const unitLess = isUnitLess(key);
      const variableId = getVariableName(key, fnString, unitLess);
      acc.push([variableId, expression, unitLess]);
      css2[key] = `var(--${variableId})`;
    } catch (ex) {
      const err = expressionValue == null ? void 0 : expressionValue.buildCodeFrameError(
        ex.message || "Could not parse function expression."
      );
      if (!err) {
        throw ex;
      }
      if ("cause" in err) {
        err.cause = ex;
      }
      throw err;
    }
  });
}
function cssFnValueToVariable({
  styleObj,
  expressionValue,
  getVariableName,
  filename,
  options,
  themeImportIdentifier,
  includeThemeArg = false
}) {
  const acc = [];
  iterateAndReplaceFunctions(
    styleObj,
    expressionValue,
    getVariableName,
    options,
    acc,
    filename != null ? filename : void 0,
    themeImportIdentifier,
    includeThemeArg
  );
  return acc;
}

// src/utils/processCssObject.ts
function processCssObject(cssObj, themeArgs, skipSx = true) {
  var _a, _b;
  const processedObj = (
    // `unstable_sx` is currently an internal API for integrating Material UI with Pigment CSS only.
    // so for Pigment CSS users, the shorthand `sx` prop is not supported yet.
    skipSx ? cssObj : ((_b = (_a = themeArgs == null ? void 0 : themeArgs.theme) == null ? void 0 : _a.unstable_sx) == null ? void 0 : _b.call(_a, cssObj)) || cssObj
  );
  const className = css(processedObj);
  return cache.registered[className];
}

export { cssFnValueToVariable, processCssObject };
//# sourceMappingURL=chunk-DH2YTSGT.mjs.map
//# sourceMappingURL=chunk-DH2YTSGT.mjs.map