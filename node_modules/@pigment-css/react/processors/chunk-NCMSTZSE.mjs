import { types } from '@babel/core';
import { parseExpression } from '@babel/parser';
import { isBoxedPrimitive } from '@wyw-in-js/shared';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
function isSerializable(o) {
  if (Array.isArray(o)) {
    return o.every(isSerializable);
  }
  if (o === null || o === void 0) {
    return true;
  }
  if (isBoxedPrimitive(o)) {
    return true;
  }
  if (typeof o === "object") {
    return Object.values(o).every(isSerializable);
  }
  return typeof o === "function" || typeof o === "string" || typeof o === "number" || typeof o === "boolean";
}
function parseAndGenerateFunction(fnString, expression) {
  var _a;
  try {
    const exp = parseExpression(fnString);
    return exp;
  } catch (ex) {
    try {
      const exp = parseExpression(`{${fnString}}`);
      if (exp.type !== "ObjectExpression") {
        throw new Error("MUI: The expression must be an object literal.");
      }
      const propMethod = exp.properties[0];
      return types.arrowFunctionExpression(propMethod.params, propMethod.body);
    } catch (ex2) {
      throw (_a = expression == null ? void 0 : expression.buildCodeFrameError(`MUI: Could not parse the expression '${fnString}'.`)) != null ? _a : new Error(`MUI: Could not parse the given expression ${fnString}`);
    }
  }
}
function valueToLiteral(value, expression) {
  var _a;
  if (value === void 0) {
    return {
      type: "Identifier",
      name: "undefined"
    };
  }
  if (typeof value === "function") {
    return parseAndGenerateFunction(value.toString(), expression);
  }
  if (isSerializable(value)) {
    if (value === null) {
      return {
        type: "NullLiteral"
      };
    }
    if (typeof value === "string") {
      return {
        type: "StringLiteral",
        value
      };
    }
    if (typeof value === "number") {
      return {
        type: "NumericLiteral",
        value
      };
    }
    if (typeof value === "boolean") {
      return {
        type: "BooleanLiteral",
        value
      };
    }
    if (Array.isArray(value)) {
      return {
        type: "ArrayExpression",
        elements: value.map((v) => valueToLiteral(v, expression))
      };
    }
    return {
      type: "ObjectExpression",
      properties: Object.entries(value).map(([key, v]) => ({
        type: "ObjectProperty",
        key: key.match(/^[a-zA-Z]\w*$/) ? {
          type: "Identifier",
          name: key
        } : {
          type: "StringLiteral",
          value: key
        },
        value: valueToLiteral(v, expression),
        computed: false,
        shorthand: false
      }))
    };
  }
  throw (_a = expression == null ? void 0 : expression.buildCodeFrameError(
    `The expression evaluated to '${value}', which is probably a mistake. If you want it to be inserted into CSS, explicitly cast or transform the value to a string, for example - 'String(${expression.source})'.`
  )) != null ? _a : new Error(`Could not convert value: "${value}" to literal.`);
}

export { valueToLiteral };
//# sourceMappingURL=chunk-NCMSTZSE.mjs.map
//# sourceMappingURL=chunk-NCMSTZSE.mjs.map