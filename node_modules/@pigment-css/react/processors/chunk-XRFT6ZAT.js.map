{"version":3,"sources":["../src/utils/valueToLiteral.ts"],"names":["isBoxedPrimitive","parseExpression","t"],"mappings":"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","file":"chunk-XRFT6ZAT.js","sourcesContent":["import { types as t } from '@babel/core';\nimport { parseExpression } from '@babel/parser';\nimport { ExpressionValue, isBoxedPrimitive } from '@wyw-in-js/shared';\nimport { Serializable } from '@wyw-in-js/transform';\n\nexport function isSerializable(o: unknown): o is Serializable {\n  if (Array.isArray(o)) {\n    return o.every(isSerializable);\n  }\n\n  if (o === null || o === undefined) {\n    return true;\n  }\n\n  if (isBoxedPrimitive(o)) {\n    return true;\n  }\n\n  if (typeof o === 'object') {\n    return Object.values(o).every(isSerializable);\n  }\n\n  return (\n    typeof o === 'function' ||\n    typeof o === 'string' ||\n    typeof o === 'number' ||\n    typeof o === 'boolean'\n  );\n}\n\nexport function parseAndGenerateFunction(fnString: string, expression?: ExpressionValue) {\n  try {\n    const exp = parseExpression(fnString);\n    // a function or an arrow function expression\n    return exp as t.FunctionExpression | t.ArrowFunctionExpression;\n  } catch (ex) {\n    try {\n      const exp = parseExpression(`{${fnString}}`);\n      if (exp.type !== 'ObjectExpression') {\n        throw new Error('MUI: The expression must be an object literal.');\n      }\n      const propMethod = exp.properties[0] as t.ObjectMethod;\n      return t.arrowFunctionExpression(propMethod.params, propMethod.body);\n    } catch (ex2) {\n      throw (\n        expression?.buildCodeFrameError(`MUI: Could not parse the expression '${fnString}'.`) ??\n        new Error(`MUI: Could not parse the given expression ${fnString}`)\n      );\n    }\n  }\n}\n\n/**\n * Converts a javascript primitive to its Babel AST node representation.\n */\nexport function valueToLiteral(value: unknown, expression?: ExpressionValue): t.Expression {\n  if (value === undefined) {\n    return {\n      type: 'Identifier',\n      name: 'undefined',\n    };\n  }\n\n  if (typeof value === 'function') {\n    return parseAndGenerateFunction(value.toString(), expression);\n  }\n\n  if (isSerializable(value)) {\n    if (value === null) {\n      return {\n        type: 'NullLiteral',\n      };\n    }\n\n    if (typeof value === 'string') {\n      return {\n        type: 'StringLiteral',\n        value,\n      };\n    }\n\n    if (typeof value === 'number') {\n      return {\n        type: 'NumericLiteral',\n        value,\n      };\n    }\n\n    if (typeof value === 'boolean') {\n      return {\n        type: 'BooleanLiteral',\n        value,\n      };\n    }\n\n    if (Array.isArray(value)) {\n      return {\n        type: 'ArrayExpression',\n        elements: value.map((v) => valueToLiteral(v, expression)),\n      };\n    }\n\n    return {\n      type: 'ObjectExpression',\n      properties: Object.entries(value).map(([key, v]) => ({\n        type: 'ObjectProperty',\n        key: key.match(/^[a-zA-Z]\\w*$/)\n          ? {\n              type: 'Identifier',\n              name: key,\n            }\n          : {\n              type: 'StringLiteral',\n              value: key,\n            },\n        value: valueToLiteral(v, expression),\n        computed: false,\n        shorthand: false,\n      })),\n    };\n  }\n\n  throw (\n    expression?.buildCodeFrameError(\n      `The expression evaluated to '${value}', which is probably a mistake. If you want it to be inserted into CSS, explicitly cast or transform the value to a string, for example - 'String(${expression.source})'.`,\n    ) ?? new Error(`Could not convert value: \"${value}\" to literal.`)\n  );\n}\n"]}