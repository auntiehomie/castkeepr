'use strict';

var chunkXRFT6ZAT_js = require('./chunk-XRFT6ZAT.js');
var chunk5VRK3JMQ_js = require('./chunk-5VRK3JMQ.js');
var chunkIWNJMGWX_js = require('./chunk-IWNJMGWX.js');
var processorUtils = require('@wyw-in-js/processor-utils');
var shared = require('@wyw-in-js/shared');
var cssesc = require('cssesc');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var cssesc__default = /*#__PURE__*/_interopDefault(cssesc);

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
function getClassName(...items) {
  return cssesc__default.default(items.filter(Boolean).join("_"));
}
function convertAtomicsToCss({
  conditions = {},
  defaultCondition,
  properties,
  shorthands = {},
  unitless = [],
  multipliers = {},
  inlineGetters = {}
}, mainClassName, isGlobal = false, debug = false, prefix = "Mui") {
  const runtimeConfig = {
    styles: {},
    shorthands,
    conditions: Object.keys(conditions),
    defaultCondition,
    unitless,
    multipliers,
    inlineGetters
  };
  let count = 1;
  function getCount() {
    const val = count;
    count += 1;
    return val;
  }
  const classes = [];
  Object.entries(conditions).forEach(([conditionName, mediaQueryStr]) => {
    Object.entries(properties).forEach(([cssPropertyName, propertyValues]) => {
      propertyValues.forEach((propertyValue) => {
        const propValue = propertyValue.startsWith("--") ? cssesc__default.default(`var(${propertyValue}-${conditionName})`) : propertyValue;
        const className = isGlobal || debug ? getClassName(
          prefix,
          cssPropertyName,
          conditionName != null ? conditionName : "default",
          propertyValue,
          !isGlobal ? mainClassName : ""
        ) : `${mainClassName}${getCount()}`;
        if (defaultCondition === conditionName || !mediaQueryStr) {
          classes.push({
            className,
            css: {
              [cssPropertyName]: propValue
            }
          });
        } else {
          classes.push({
            className,
            css: {
              [mediaQueryStr]: {
                [cssPropertyName]: propValue
              }
            }
          });
        }
        if (!runtimeConfig.styles[cssPropertyName]) {
          runtimeConfig.styles[cssPropertyName] = {};
        }
        if (!runtimeConfig.styles[cssPropertyName][propertyValue]) {
          runtimeConfig.styles[cssPropertyName][propertyValue] = {};
        }
        runtimeConfig.styles[cssPropertyName][propertyValue][conditionName] = className;
      });
    });
  });
  return {
    classes,
    runtimeConfig
  };
}

// src/processors/generateAtomics.ts
var GenerateAtomicsProcessor = class extends chunkIWNJMGWX_js.BaseProcessor {
  constructor(params, ...args) {
    super([params[0]], ...args);
    if (params.length <= 1) {
      throw chunkIWNJMGWX_js.BaseProcessor.SKIP;
    }
    processorUtils.validateParams(params, ["callee", ["call"]], `Invalid use of ${this.tagSource.imported} tag.`);
    const [, callParam] = params;
    const [, callParamArgument] = callParam;
    this.dependencies.push(callParamArgument);
    this.callParam = callParamArgument;
  }
  // eslint-disable-next-line class-methods-use-this
  get asSelector() {
    throw new Error("Method not implemented.");
  }
  // eslint-disable-next-line class-methods-use-this
  get value() {
    throw new Error("Method not implemented.");
  }
  doEvaltimeReplacement() {
    this.replacer(this.astService.nullLiteral(), true);
  }
  build(values) {
    const { themeArgs = {} } = this.options;
    const param = this.callParam;
    if (param.kind !== shared.ValueType.CONST) {
      const value = param.kind === shared.ValueType.FUNCTION ? values.get(param.ex.name)(themeArgs) : values.get(param.ex.name);
      const { classes, runtimeConfig } = convertAtomicsToCss(
        value,
        this.className,
        false,
        this.options.displayName
      );
      this.runtimeConfig = runtimeConfig;
      classes.forEach(({ className, css: cssObject }) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const emotionClass = chunk5VRK3JMQ_js.css(cssObject);
        const cssText = chunk5VRK3JMQ_js.cache.registered[emotionClass];
        const rules = {
          [`.${className}`]: {
            cssText,
            className: this.className,
            displayName: this.displayName,
            start: (_b = (_a = this.location) == null ? void 0 : _a.start) != null ? _b : null
          }
        };
        const sourceMapReplacements = [
          {
            length: cssText.length,
            original: {
              start: {
                column: (_d = (_c = this.location) == null ? void 0 : _c.start.column) != null ? _d : 0,
                line: (_f = (_e = this.location) == null ? void 0 : _e.start.line) != null ? _f : 0
              },
              end: {
                column: (_h = (_g = this.location) == null ? void 0 : _g.end.column) != null ? _h : 0,
                line: (_j = (_i = this.location) == null ? void 0 : _i.end.line) != null ? _j : 0
              }
            }
          }
        ];
        this.artifacts.push(["css", [rules, sourceMapReplacements]]);
      });
    }
  }
  doRuntimeReplacement() {
    if (!this.runtimeConfig) {
      this.doEvaltimeReplacement();
      return;
    }
    const { astService: t } = this;
    const importName = t.addNamedImport("atomics", this.getImportPath());
    this.replacer(t.callExpression(importName, [chunkXRFT6ZAT_js.valueToLiteral(this.runtimeConfig)]), true);
  }
};

exports.GenerateAtomicsProcessor = GenerateAtomicsProcessor;
//# sourceMappingURL=generateAtomics.js.map
//# sourceMappingURL=generateAtomics.js.map