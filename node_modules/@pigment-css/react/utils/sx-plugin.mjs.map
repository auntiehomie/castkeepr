{"version":3,"sources":["../src/utils/checkStaticObjectOrArray.ts","../src/utils/isUnitLess.ts","../src/utils/sxObjectExtractor.ts","../src/utils/sxPropConverter.ts","../src/utils/sx-plugin.ts"],"names":[],"mappings":"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","file":"sx-plugin.mjs","sourcesContent":["import type { NodePath } from '@babel/core';\nimport type * as t from '@babel/types';\n\nexport function isStaticObjectExpression(\n  nodePath: NodePath<t.ObjectExpression>,\n): nodePath is NodePath<t.ObjectExpression> {\n  const properties = nodePath.get('properties');\n  return properties.every((property): boolean => {\n    if (!property.isObjectProperty()) {\n      return false;\n    }\n    const key = property.get('key');\n    const value = property.get('value');\n    return (\n      (key.isIdentifier() && value.isLiteral()) ||\n      (value.isObjectExpression() && isStaticObjectExpression(value))\n    );\n  });\n}\n\n/**\n * Recursively check if all items in an array or all keys and values in\n * an object are static.\n */\nexport function isStaticObjectOrArrayExpression(\n  nodePath: NodePath<t.Expression>,\n): nodePath is NodePath<t.ArrayExpression> | NodePath<t.ObjectExpression> {\n  if (nodePath.isArrayExpression()) {\n    const elements = nodePath.get('elements');\n    return elements.every((item) => {\n      if (item.isLiteral()) {\n        return true;\n      }\n      if (item.isObjectExpression()) {\n        return isStaticObjectExpression(item);\n      }\n      if (item.isArrayExpression()) {\n        return isStaticObjectOrArrayExpression(nodePath);\n      }\n      return false;\n    });\n  }\n  if (nodePath.isObjectExpression()) {\n    return isStaticObjectExpression(nodePath);\n  }\n  return false;\n}\n","// Copied over from https://github.com/emotion-js/emotion/blob/main/packages/unitless/src/index.js\n// since typings of @emotion/unitless are broken. PR to fix here - https://github.com/emotion-js/emotion/pull/3088\nconst unitlessKeys: { [key: string]: 1 } = {\n  animationIterationCount: 1,\n  aspectRatio: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  msGridRow: 1,\n  msGridRowSpan: 1,\n  msGridColumn: 1,\n  msGridColumnSpan: 1,\n  fontWeight: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  WebkitLineClamp: 1,\n\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n};\n\nexport function isUnitLess(cssKey: string) {\n  return unitlessKeys[cssKey] === 1 || cssKey.startsWith('--');\n}\n","import type { NodePath } from '@babel/core';\nimport {\n  arrayExpression,\n  arrowFunctionExpression,\n  booleanLiteral,\n  cloneNode,\n  stringLiteral,\n} from '@babel/types';\nimport type {\n  ArrowFunctionExpression,\n  Expression,\n  Identifier,\n  ObjectExpression,\n  PrivateName,\n} from '@babel/types';\nimport { findIdentifiers } from '@wyw-in-js/transform';\nimport { isStaticObjectOrArrayExpression } from './checkStaticObjectOrArray';\nimport { isUnitLess } from './isUnitLess';\n\nfunction validateObjectKey(\n  keyPath: NodePath<PrivateName | Expression>,\n  parentCall?: NodePath<ArrowFunctionExpression>,\n) {\n  const rootScope = keyPath.scope.getProgramParent();\n  if (keyPath.isIdentifier()) {\n    return;\n  }\n  const identifiers = findIdentifiers([keyPath]);\n  if (!identifiers.length) {\n    return;\n  }\n\n  // check if all the identifiers being used for the key, if it is not a static value,\n  // (ie, [theme.apply()] or [globalVariable]) are globally defined or not.\n  // Global means in the root scope (file scope) or in the same scope as the parentCall\n  const areAllGlobalIdentifiers = identifiers.every((item) => {\n    // get the definition AST node path of the identifier\n    const binding = item.scope.getBinding(item.node.name);\n    if (!binding) {\n      return false;\n    }\n    if (\n      // if the identifier is defined in the same scope as the parentCall, ie, ({theme}) => ({color: theme.color})\n      binding.path.findParent((parent) => parent === parentCall) ||\n      // if the identifier is defined in the file scope\n      binding.path.scope === rootScope\n    ) {\n      return true;\n    }\n    return false;\n  });\n\n  if (!parentCall) {\n    if (areAllGlobalIdentifiers) {\n      return;\n    }\n    throw keyPath.buildCodeFrameError(\n      `${process.env.PACKAGE_NAME}: Expressions in css object keys are not supported.`,\n    );\n  }\n  if (!areAllGlobalIdentifiers) {\n    throw keyPath.buildCodeFrameError(\n      `${process.env.PACKAGE_NAME}: Variables in css object keys should only use the passed theme(s) object or variables that are defined in the root scope.`,\n    );\n  }\n}\n\nfunction traverseObjectExpression(\n  nodePath: NodePath<ObjectExpression>,\n  parentCall?: NodePath<ArrowFunctionExpression>,\n) {\n  const rootScope = nodePath.scope.getProgramParent();\n  const properties = nodePath.get('properties');\n  properties.forEach((property) => {\n    if (property.isObjectProperty()) {\n      const key = property.get('key');\n      validateObjectKey(key, parentCall);\n\n      const value = property.get('value');\n      if (!value.isExpression()) {\n        throw value.buildCodeFrameError(\n          `${process.env.PACKAGE_NAME}: This value is not supported. It can only be static values or local variables.`,\n        );\n      }\n      if (value.isObjectExpression()) {\n        traverseObjectExpression(value, parentCall);\n      } else if (!value.isLiteral() && !isStaticObjectOrArrayExpression(value)) {\n        const identifiers = findIdentifiers([value], 'reference');\n        const localIdentifiers: NodePath<Identifier>[] = [];\n        identifiers.forEach((id) => {\n          if (!id.isIdentifier()) {\n            return;\n          }\n          const binding = id.scope.getBinding(id.node.name);\n          if (!binding) {\n            return;\n          }\n          if ((parentCall && binding.scope === parentCall.scope) || binding.scope === rootScope) {\n            return;\n          }\n          localIdentifiers.push(id);\n        });\n        if (localIdentifiers.length) {\n          let cssKey = '';\n          if (key.isIdentifier()) {\n            cssKey = key.node.name;\n          } else if (key.isStringLiteral()) {\n            cssKey = key.node.value;\n          }\n          const unitLess = isUnitLess(cssKey);\n          const fnBody = arrayExpression([cloneNode(value.node), booleanLiteral(unitLess)]);\n          // Serialize the actual AST as a string\n          // which then gets deserialized in sx.ts\n          const arrowFn = arrowFunctionExpression([], stringLiteral(JSON.stringify(fnBody)));\n          value.replaceWith(arrowFn);\n        }\n      }\n    } else if (property.isSpreadElement()) {\n      const identifiers = findIdentifiers([property.get('argument')]);\n      if (\n        !identifiers.every((id) => {\n          const binding = property.scope.getBinding(id.node.name);\n          // the indentifier definition should either be in the root scope or in the same scope\n          // as the object property, ie, ({theme}) => ({...theme.applyStyles()})\n          return binding && (binding.scope === rootScope || binding.scope === property.scope);\n        })\n      ) {\n        throw property.buildCodeFrameError(\n          `${process.env.PACKAGE_NAME}: You can only use variables in the spread that are defined in the root scope of the file.`,\n        );\n      }\n    } else if (property.isObjectMethod()) {\n      throw property.buildCodeFrameError(\n        `${process.env.PACKAGE_NAME}: sx prop object does not support ObjectMethods.`,\n      );\n    } else {\n      throw property.buildCodeFrameError(\n        `${process.env.PACKAGE_NAME}: Unknown property in object.`,\n      );\n    }\n  });\n}\n\nexport function sxObjectExtractor(nodePath: NodePath<ObjectExpression | ArrowFunctionExpression>) {\n  if (nodePath.isObjectExpression()) {\n    traverseObjectExpression(nodePath);\n  } else if (nodePath.isArrowFunctionExpression()) {\n    const body = nodePath.get('body');\n    if (!body.isObjectExpression()) {\n      throw body.buildCodeFrameError(\n        `${process.env.PACKAGE_NAME}: sx prop only supports arrow functions directly returning an object, for example () => ({color: 'red'}). You can accept theme object in the params if required.`,\n      );\n    }\n    traverseObjectExpression(body, nodePath);\n  }\n}\n","import { NodePath } from '@babel/core';\nimport { ArrowFunctionExpression, Expression, ObjectExpression } from '@babel/types';\nimport { sxObjectExtractor } from './sxObjectExtractor';\n\nfunction isAllowedExpression(\n  node: NodePath<Expression>,\n): node is NodePath<ObjectExpression> | NodePath<ArrowFunctionExpression> {\n  return (\n    node.isObjectExpression() || node.isArrowFunctionExpression() || node.isFunctionExpression()\n  );\n}\n\nexport function sxPropConverter(\n  node: NodePath<Expression>,\n  wrapWithSxCall: (expPath: NodePath<Expression>) => void,\n) {\n  if (node.isArrayExpression()) {\n    node.get('elements').forEach((element) => {\n      if (element.isExpression()) {\n        sxPropConverter(element, wrapWithSxCall);\n      }\n    });\n  } else if (node.isConditionalExpression()) {\n    const consequent = node.get('consequent');\n    const alternate = node.get('alternate');\n\n    if (isAllowedExpression(consequent)) {\n      sxObjectExtractor(consequent);\n      wrapWithSxCall(consequent);\n    }\n    if (isAllowedExpression(alternate)) {\n      sxObjectExtractor(alternate);\n      wrapWithSxCall(alternate);\n    }\n  } else if (node.isLogicalExpression()) {\n    const right = node.get('right');\n    if (isAllowedExpression(right)) {\n      sxObjectExtractor(right);\n      wrapWithSxCall(right);\n    }\n  } else if (isAllowedExpression(node)) {\n    sxObjectExtractor(node);\n    wrapWithSxCall(node);\n  } else if (node.isIdentifier()) {\n    const rootScope = node.scope.getProgramParent();\n    const binding = node.scope.getBinding(node.node.name);\n    // Simplest case, ie, const styles = {static object}\n    // and is used as <Component sx={styles} />\n    if (binding?.scope === rootScope) {\n      wrapWithSxCall(node);\n    }\n  } else if (node.isMemberExpression()) {\n    let current: NodePath<Expression> = node;\n    while (current.isMemberExpression()) {\n      current = current.get('object');\n    }\n    if (current.isIdentifier()) {\n      const rootScope = current.scope.getProgramParent();\n      const binding = current.scope.getBinding(current.node.name);\n      if (binding?.scope === rootScope) {\n        wrapWithSxCall(node);\n      }\n    }\n  }\n}\n","import { addNamed } from '@babel/helper-module-imports';\nimport { declare } from '@babel/helper-plugin-utils';\nimport { NodePath } from '@babel/core';\nimport * as Types from '@babel/types';\n\nimport { sxPropConverter } from './sxPropConverter';\n\nfunction convertJsxMemberExpressionToMemberExpression(\n  t: typeof Types,\n  nodePath: NodePath<Types.JSXMemberExpression>,\n): Types.MemberExpression {\n  const object = nodePath.get('object');\n  const property = nodePath.get('property');\n\n  if (object.isJSXMemberExpression()) {\n    return t.memberExpression(\n      convertJsxMemberExpressionToMemberExpression(t, object),\n      t.identifier(property.node.name),\n    );\n  }\n  return t.memberExpression(\n    t.identifier((object.node as Types.JSXIdentifier).name),\n    t.identifier(property.node.name),\n  );\n}\n\nfunction replaceNodePath(\n  expressionPath: NodePath<Types.Expression>,\n  namePath: NodePath<Types.JSXIdentifier | Types.Identifier>,\n  importName: string,\n  t: typeof Types,\n  tagNamePath: NodePath<\n    Types.JSXIdentifier | Types.Identifier | Types.JSXMemberExpression | Types.MemberExpression\n  >,\n) {\n  const sxIdentifier = addNamed(namePath, importName, process.env.PACKAGE_NAME as string);\n\n  const wrapWithSxCall = (expPath: NodePath<Types.Expression>) => {\n    let tagNameArg: Types.Identifier | Types.MemberExpression | null = null;\n    if (tagNamePath.isJSXIdentifier()) {\n      tagNameArg = t.identifier(tagNamePath.node.name);\n    } else if (tagNamePath.isJSXMemberExpression()) {\n      tagNameArg = convertJsxMemberExpressionToMemberExpression(t, tagNamePath);\n    } else {\n      tagNameArg = tagNamePath.node as Types.Identifier | Types.MemberExpression;\n    }\n    expPath.replaceWith(t.callExpression(sxIdentifier, [expPath.node, tagNameArg]));\n  };\n\n  sxPropConverter(expressionPath, wrapWithSxCall);\n}\n\nexport const babelPlugin = declare<{\n  propName?: string;\n  importName?: string;\n  sxComponentName?: string;\n}>((api, { propName = 'sx', importName = 'sx' }) => {\n  api.assertVersion(7);\n  const { types: t } = api;\n  return {\n    name: '@pigmentcss/sx-plugin',\n    visitor: {\n      JSXAttribute(path) {\n        const namePath = path.get('name');\n        const openingElement = path.findParent((p) => p.isJSXOpeningElement());\n        if (\n          !openingElement ||\n          !openingElement.isJSXOpeningElement() ||\n          !namePath.isJSXIdentifier() ||\n          namePath.node.name !== propName\n        ) {\n          return;\n        }\n        const tagName = openingElement.get('name');\n        const valuePath = path.get('value');\n        if (!valuePath.isJSXExpressionContainer()) {\n          return;\n        }\n        const expressionPath = valuePath.get('expression');\n        if (!expressionPath.isExpression()) {\n          return;\n        }\n        // @ts-ignore\n        replaceNodePath(expressionPath, namePath, importName, t, tagName);\n      },\n      ObjectProperty(path) {\n        // @TODO - Maybe add support for React.createElement calls as well.\n        // Right now, it only checks for jsx(),jsxs(),jsxDEV() and jsxsDEV() calls.\n        const keyPath = path.get('key');\n        if (!keyPath.isIdentifier() || keyPath.node.name !== propName) {\n          return;\n        }\n        const valuePath = path.get('value');\n        if (\n          !valuePath.isIdentifier() &&\n          !valuePath.isMemberExpression() &&\n          !valuePath.isArrayExpression() &&\n          !valuePath.isObjectExpression() &&\n          !valuePath.isArrowFunctionExpression() &&\n          !valuePath.isConditionalExpression() &&\n          !valuePath.isLogicalExpression()\n        ) {\n          return;\n        }\n        const parentJsxCall = path.findParent((p) => p.isCallExpression());\n        if (!parentJsxCall || !parentJsxCall.isCallExpression()) {\n          return;\n        }\n        const callee = parentJsxCall.get('callee');\n        if (!callee.isIdentifier() || !callee.node.name.includes('jsx')) {\n          return;\n        }\n        const jsxElement = parentJsxCall.get('arguments')[0] as NodePath<Types.Identifier>;\n        replaceNodePath(valuePath, keyPath, importName, t, jsxElement);\n      },\n    },\n  };\n});\n"]}