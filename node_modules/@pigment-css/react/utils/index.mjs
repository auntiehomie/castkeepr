import { __objRest, __spreadProps, __spreadValues } from './chunk-L25ZX2YK.mjs';
import { middleware, stringify, serialize, compile } from 'stylis';
import rtlPlugin from 'stylis-plugin-rtl';
import { serializeStyles } from '@emotion/serialize';
import { prepareCssVars } from '@mui/system/cssVars';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
function globalSelector(element) {
  switch (element.type) {
    case "rule":
      element.props = element.props.map((value) => {
        if (value.match(/(:where|:is)\(/)) {
          value = value.replace(/\.[^:]+(:where|:is)/, "$1");
          return value;
        }
        return value;
      });
      break;
  }
}
function getSerializer(includeRtl) {
  if (!includeRtl) {
    return middleware([globalSelector, stringify]);
  }
  return middleware([globalSelector, rtlPlugin, stringify]);
}
var serializerLtr = getSerializer();
var serializerRtl = getSerializer(true);
var stylis = (css, serializerParam) => serialize(compile(css), serializerParam);
var defaultGetDirSelector = (dir) => `[dir=${dir}]`;
function getGlobalSelector(asSelector) {
  return `$$GLOBAL-${asSelector}`;
}
function preprocessor(selector, cssText, options) {
  const {
    defaultDirection = "ltr",
    generateForBothDir = false,
    getDirSelector = defaultGetDirSelector
  } = options || {};
  const serializer = defaultDirection === "ltr" ? serializerLtr : serializerRtl;
  let css = "";
  const isGlobal = selector.startsWith(getGlobalSelector(""));
  if (!isGlobal && cssText.startsWith("@keyframes")) {
    css += stylis(cssText.replace("@keyframes", `@keyframes ${selector}`), serializer);
    return css;
  }
  css += stylis(!isGlobal ? `${selector}{${cssText}}` : cssText, serializer);
  if (generateForBothDir) {
    const otherSerializer = defaultDirection === "ltr" ? serializerRtl : serializerLtr;
    css += stylis(
      `${getDirSelector(defaultDirection === "ltr" ? "rtl" : "ltr")} ${!isGlobal ? `${selector}{${cssText}}` : cssText}`,
      otherSerializer
    );
  }
  return css;
}
function matchAdapterPath(path) {
  return path.includes("zero-styled");
}
function generateTokenCss(theme) {
  var _a;
  if (!theme) {
    return "";
  }
  const { styles } = serializeStyles(((_a = theme.generateStyleSheets) == null ? void 0 : _a.call(theme)) || []);
  return styles;
}
function generateThemeTokens(theme) {
  if (!theme || typeof theme !== "object") {
    return {};
  }
  if ("vars" in theme && theme.vars) {
    return {
      vars: theme.vars
    };
  }
  return {};
}
function extendTheme(theme) {
  const _a = theme, {
    cssVarPrefix,
    shouldSkipGeneratingVar,
    getSelector = defaultGetSelector,
    defaultColorScheme = "light"
  } = _a, otherTheme = __objRest(_a, [
    "cssVarPrefix",
    "shouldSkipGeneratingVar",
    "getSelector",
    "defaultColorScheme"
  ]);
  function defaultGetSelector(colorScheme, css) {
    if (colorScheme === "light" && defaultColorScheme !== "light") {
      return {
        "@media (prefers-color-scheme: light)": {
          ":root": css
        }
      };
    }
    if (colorScheme === "dark" && defaultColorScheme !== "dark") {
      return {
        "@media (prefers-color-scheme: dark)": {
          ":root": css
        }
      };
    }
    return ":root";
  }
  if (theme.colorSchemes && (!defaultColorScheme || !Object.keys(theme.colorSchemes).includes(defaultColorScheme))) {
    throw new Error(
      `Zero: \`defaultColorScheme\` must be one of ${JSON.stringify(
        theme.colorSchemes
      )}, but got "\`${theme.defaultColorScheme}\`".`
    );
  }
  const parserConfig = {
    prefix: cssVarPrefix,
    shouldSkipGeneratingVar,
    getSelector
  };
  const { generateThemeVars, generateStyleSheets } = prepareCssVars(otherTheme, parserConfig);
  const finalTheme = __spreadProps(__spreadValues({}, theme), {
    defaultColorScheme,
    vars: generateThemeVars(),
    generateStyleSheets
  });
  finalTheme.getColorSchemeSelector = (colorScheme) => {
    if (!theme.getSelector) {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    return `:where(${theme.getSelector(colorScheme, {})}) &`;
  };
  finalTheme.applyStyles = function applyStyles(colorScheme, styles) {
    return {
      [this.getColorSchemeSelector(colorScheme)]: styles
    };
  };
  return finalTheme;
}

// src/utils/generateThemeSource.ts
function generateThemeSource(theme) {
  if (!theme) {
    return `export default {}`;
  }
  if (typeof theme.toRuntimeSource !== "function") {
    return `export default ${JSON.stringify(generateThemeTokens(theme))};`;
  }
  return theme.toRuntimeSource.call(theme, theme);
}

export { extendTheme, generateThemeSource, generateThemeTokens, generateTokenCss, getGlobalSelector, matchAdapterPath, preprocessor };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map