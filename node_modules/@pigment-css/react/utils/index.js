'use strict';

var chunkQMF3JN35_js = require('./chunk-QMF3JN35.js');
var stylis$1 = require('stylis');
var rtlPlugin = require('stylis-plugin-rtl');
var serialize = require('@emotion/serialize');
var cssVars = require('@mui/system/cssVars');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var rtlPlugin__default = /*#__PURE__*/_interopDefault(rtlPlugin);

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
function globalSelector(element) {
  switch (element.type) {
    case "rule":
      element.props = element.props.map((value) => {
        if (value.match(/(:where|:is)\(/)) {
          value = value.replace(/\.[^:]+(:where|:is)/, "$1");
          return value;
        }
        return value;
      });
      break;
  }
}
function getSerializer(includeRtl) {
  if (!includeRtl) {
    return stylis$1.middleware([globalSelector, stylis$1.stringify]);
  }
  return stylis$1.middleware([globalSelector, rtlPlugin__default.default, stylis$1.stringify]);
}
var serializerLtr = getSerializer();
var serializerRtl = getSerializer(true);
var stylis = (css, serializerParam) => stylis$1.serialize(stylis$1.compile(css), serializerParam);
var defaultGetDirSelector = (dir) => `[dir=${dir}]`;
function getGlobalSelector(asSelector) {
  return `$$GLOBAL-${asSelector}`;
}
function preprocessor(selector, cssText, options) {
  const {
    defaultDirection = "ltr",
    generateForBothDir = false,
    getDirSelector = defaultGetDirSelector
  } = options || {};
  const serializer = defaultDirection === "ltr" ? serializerLtr : serializerRtl;
  let css = "";
  const isGlobal = selector.startsWith(getGlobalSelector(""));
  if (!isGlobal && cssText.startsWith("@keyframes")) {
    css += stylis(cssText.replace("@keyframes", `@keyframes ${selector}`), serializer);
    return css;
  }
  css += stylis(!isGlobal ? `${selector}{${cssText}}` : cssText, serializer);
  if (generateForBothDir) {
    const otherSerializer = defaultDirection === "ltr" ? serializerRtl : serializerLtr;
    css += stylis(
      `${getDirSelector(defaultDirection === "ltr" ? "rtl" : "ltr")} ${!isGlobal ? `${selector}{${cssText}}` : cssText}`,
      otherSerializer
    );
  }
  return css;
}
function matchAdapterPath(path) {
  return path.includes("zero-styled");
}
function generateTokenCss(theme) {
  var _a;
  if (!theme) {
    return "";
  }
  const { styles } = serialize.serializeStyles(((_a = theme.generateStyleSheets) == null ? void 0 : _a.call(theme)) || []);
  return styles;
}
function generateThemeTokens(theme) {
  if (!theme || typeof theme !== "object") {
    return {};
  }
  if ("vars" in theme && theme.vars) {
    return {
      vars: theme.vars
    };
  }
  return {};
}
function extendTheme(theme) {
  const _a = theme, {
    cssVarPrefix,
    shouldSkipGeneratingVar,
    getSelector = defaultGetSelector,
    defaultColorScheme = "light"
  } = _a, otherTheme = chunkQMF3JN35_js.__objRest(_a, [
    "cssVarPrefix",
    "shouldSkipGeneratingVar",
    "getSelector",
    "defaultColorScheme"
  ]);
  function defaultGetSelector(colorScheme, css) {
    if (colorScheme === "light" && defaultColorScheme !== "light") {
      return {
        "@media (prefers-color-scheme: light)": {
          ":root": css
        }
      };
    }
    if (colorScheme === "dark" && defaultColorScheme !== "dark") {
      return {
        "@media (prefers-color-scheme: dark)": {
          ":root": css
        }
      };
    }
    return ":root";
  }
  if (theme.colorSchemes && (!defaultColorScheme || !Object.keys(theme.colorSchemes).includes(defaultColorScheme))) {
    throw new Error(
      `Zero: \`defaultColorScheme\` must be one of ${JSON.stringify(
        theme.colorSchemes
      )}, but got "\`${theme.defaultColorScheme}\`".`
    );
  }
  const parserConfig = {
    prefix: cssVarPrefix,
    shouldSkipGeneratingVar,
    getSelector
  };
  const { generateThemeVars, generateStyleSheets } = cssVars.prepareCssVars(otherTheme, parserConfig);
  const finalTheme = chunkQMF3JN35_js.__spreadProps(chunkQMF3JN35_js.__spreadValues({}, theme), {
    defaultColorScheme,
    vars: generateThemeVars(),
    generateStyleSheets
  });
  finalTheme.getColorSchemeSelector = (colorScheme) => {
    if (!theme.getSelector) {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    return `:where(${theme.getSelector(colorScheme, {})}) &`;
  };
  finalTheme.applyStyles = function applyStyles(colorScheme, styles) {
    return {
      [this.getColorSchemeSelector(colorScheme)]: styles
    };
  };
  return finalTheme;
}

// src/utils/generateThemeSource.ts
function generateThemeSource(theme) {
  if (!theme) {
    return `export default {}`;
  }
  if (typeof theme.toRuntimeSource !== "function") {
    return `export default ${JSON.stringify(generateThemeTokens(theme))};`;
  }
  return theme.toRuntimeSource.call(theme, theme);
}

exports.extendTheme = extendTheme;
exports.generateThemeSource = generateThemeSource;
exports.generateThemeTokens = generateThemeTokens;
exports.generateTokenCss = generateTokenCss;
exports.getGlobalSelector = getGlobalSelector;
exports.matchAdapterPath = matchAdapterPath;
exports.preprocessor = preprocessor;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map