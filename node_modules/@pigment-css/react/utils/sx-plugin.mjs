import './chunk-L25ZX2YK.mjs';
import { addNamed } from '@babel/helper-module-imports';
import { declare } from '@babel/helper-plugin-utils';
import { arrayExpression, cloneNode, booleanLiteral, arrowFunctionExpression, stringLiteral } from '@babel/types';
import { findIdentifiers } from '@wyw-in-js/transform';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 

// src/utils/checkStaticObjectOrArray.ts
function isStaticObjectExpression(nodePath) {
  const properties = nodePath.get("properties");
  return properties.every((property) => {
    if (!property.isObjectProperty()) {
      return false;
    }
    const key = property.get("key");
    const value = property.get("value");
    return key.isIdentifier() && value.isLiteral() || value.isObjectExpression() && isStaticObjectExpression(value);
  });
}
function isStaticObjectOrArrayExpression(nodePath) {
  if (nodePath.isArrayExpression()) {
    const elements = nodePath.get("elements");
    return elements.every((item) => {
      if (item.isLiteral()) {
        return true;
      }
      if (item.isObjectExpression()) {
        return isStaticObjectExpression(item);
      }
      if (item.isArrayExpression()) {
        return isStaticObjectOrArrayExpression(nodePath);
      }
      return false;
    });
  }
  if (nodePath.isObjectExpression()) {
    return isStaticObjectExpression(nodePath);
  }
  return false;
}

// src/utils/isUnitLess.ts
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function isUnitLess(cssKey) {
  return unitlessKeys[cssKey] === 1 || cssKey.startsWith("--");
}

// src/utils/sxObjectExtractor.ts
function validateObjectKey(keyPath, parentCall) {
  const rootScope = keyPath.scope.getProgramParent();
  if (keyPath.isIdentifier()) {
    return;
  }
  const identifiers = findIdentifiers([keyPath]);
  if (!identifiers.length) {
    return;
  }
  const areAllGlobalIdentifiers = identifiers.every((item) => {
    const binding = item.scope.getBinding(item.node.name);
    if (!binding) {
      return false;
    }
    if (
      // if the identifier is defined in the same scope as the parentCall, ie, ({theme}) => ({color: theme.color})
      binding.path.findParent((parent) => parent === parentCall) || // if the identifier is defined in the file scope
      binding.path.scope === rootScope
    ) {
      return true;
    }
    return false;
  });
  if (!parentCall) {
    if (areAllGlobalIdentifiers) {
      return;
    }
    throw keyPath.buildCodeFrameError(
      `${"@pigment-css/react"}: Expressions in css object keys are not supported.`
    );
  }
  if (!areAllGlobalIdentifiers) {
    throw keyPath.buildCodeFrameError(
      `${"@pigment-css/react"}: Variables in css object keys should only use the passed theme(s) object or variables that are defined in the root scope.`
    );
  }
}
function traverseObjectExpression(nodePath, parentCall) {
  const rootScope = nodePath.scope.getProgramParent();
  const properties = nodePath.get("properties");
  properties.forEach((property) => {
    if (property.isObjectProperty()) {
      const key = property.get("key");
      validateObjectKey(key, parentCall);
      const value = property.get("value");
      if (!value.isExpression()) {
        throw value.buildCodeFrameError(
          `${"@pigment-css/react"}: This value is not supported. It can only be static values or local variables.`
        );
      }
      if (value.isObjectExpression()) {
        traverseObjectExpression(value, parentCall);
      } else if (!value.isLiteral() && !isStaticObjectOrArrayExpression(value)) {
        const identifiers = findIdentifiers([value], "reference");
        const localIdentifiers = [];
        identifiers.forEach((id) => {
          if (!id.isIdentifier()) {
            return;
          }
          const binding = id.scope.getBinding(id.node.name);
          if (!binding) {
            return;
          }
          if (parentCall && binding.scope === parentCall.scope || binding.scope === rootScope) {
            return;
          }
          localIdentifiers.push(id);
        });
        if (localIdentifiers.length) {
          let cssKey = "";
          if (key.isIdentifier()) {
            cssKey = key.node.name;
          } else if (key.isStringLiteral()) {
            cssKey = key.node.value;
          }
          const unitLess = isUnitLess(cssKey);
          const fnBody = arrayExpression([cloneNode(value.node), booleanLiteral(unitLess)]);
          const arrowFn = arrowFunctionExpression([], stringLiteral(JSON.stringify(fnBody)));
          value.replaceWith(arrowFn);
        }
      }
    } else if (property.isSpreadElement()) {
      const identifiers = findIdentifiers([property.get("argument")]);
      if (!identifiers.every((id) => {
        const binding = property.scope.getBinding(id.node.name);
        return binding && (binding.scope === rootScope || binding.scope === property.scope);
      })) {
        throw property.buildCodeFrameError(
          `${"@pigment-css/react"}: You can only use variables in the spread that are defined in the root scope of the file.`
        );
      }
    } else if (property.isObjectMethod()) {
      throw property.buildCodeFrameError(
        `${"@pigment-css/react"}: sx prop object does not support ObjectMethods.`
      );
    } else {
      throw property.buildCodeFrameError(
        `${"@pigment-css/react"}: Unknown property in object.`
      );
    }
  });
}
function sxObjectExtractor(nodePath) {
  if (nodePath.isObjectExpression()) {
    traverseObjectExpression(nodePath);
  } else if (nodePath.isArrowFunctionExpression()) {
    const body = nodePath.get("body");
    if (!body.isObjectExpression()) {
      throw body.buildCodeFrameError(
        `${"@pigment-css/react"}: sx prop only supports arrow functions directly returning an object, for example () => ({color: 'red'}). You can accept theme object in the params if required.`
      );
    }
    traverseObjectExpression(body, nodePath);
  }
}

// src/utils/sxPropConverter.ts
function isAllowedExpression(node) {
  return node.isObjectExpression() || node.isArrowFunctionExpression() || node.isFunctionExpression();
}
function sxPropConverter(node, wrapWithSxCall) {
  if (node.isArrayExpression()) {
    node.get("elements").forEach((element) => {
      if (element.isExpression()) {
        sxPropConverter(element, wrapWithSxCall);
      }
    });
  } else if (node.isConditionalExpression()) {
    const consequent = node.get("consequent");
    const alternate = node.get("alternate");
    if (isAllowedExpression(consequent)) {
      sxObjectExtractor(consequent);
      wrapWithSxCall(consequent);
    }
    if (isAllowedExpression(alternate)) {
      sxObjectExtractor(alternate);
      wrapWithSxCall(alternate);
    }
  } else if (node.isLogicalExpression()) {
    const right = node.get("right");
    if (isAllowedExpression(right)) {
      sxObjectExtractor(right);
      wrapWithSxCall(right);
    }
  } else if (isAllowedExpression(node)) {
    sxObjectExtractor(node);
    wrapWithSxCall(node);
  } else if (node.isIdentifier()) {
    const rootScope = node.scope.getProgramParent();
    const binding = node.scope.getBinding(node.node.name);
    if ((binding == null ? void 0 : binding.scope) === rootScope) {
      wrapWithSxCall(node);
    }
  } else if (node.isMemberExpression()) {
    let current = node;
    while (current.isMemberExpression()) {
      current = current.get("object");
    }
    if (current.isIdentifier()) {
      const rootScope = current.scope.getProgramParent();
      const binding = current.scope.getBinding(current.node.name);
      if ((binding == null ? void 0 : binding.scope) === rootScope) {
        wrapWithSxCall(node);
      }
    }
  }
}

// src/utils/sx-plugin.ts
function convertJsxMemberExpressionToMemberExpression(t, nodePath) {
  const object = nodePath.get("object");
  const property = nodePath.get("property");
  if (object.isJSXMemberExpression()) {
    return t.memberExpression(
      convertJsxMemberExpressionToMemberExpression(t, object),
      t.identifier(property.node.name)
    );
  }
  return t.memberExpression(
    t.identifier(object.node.name),
    t.identifier(property.node.name)
  );
}
function replaceNodePath(expressionPath, namePath, importName, t, tagNamePath) {
  const sxIdentifier = addNamed(namePath, importName, "@pigment-css/react");
  const wrapWithSxCall = (expPath) => {
    let tagNameArg = null;
    if (tagNamePath.isJSXIdentifier()) {
      tagNameArg = t.identifier(tagNamePath.node.name);
    } else if (tagNamePath.isJSXMemberExpression()) {
      tagNameArg = convertJsxMemberExpressionToMemberExpression(t, tagNamePath);
    } else {
      tagNameArg = tagNamePath.node;
    }
    expPath.replaceWith(t.callExpression(sxIdentifier, [expPath.node, tagNameArg]));
  };
  sxPropConverter(expressionPath, wrapWithSxCall);
}
var babelPlugin = declare((api, { propName = "sx", importName = "sx" }) => {
  api.assertVersion(7);
  const { types: t } = api;
  return {
    name: "@pigmentcss/sx-plugin",
    visitor: {
      JSXAttribute(path) {
        const namePath = path.get("name");
        const openingElement = path.findParent((p) => p.isJSXOpeningElement());
        if (!openingElement || !openingElement.isJSXOpeningElement() || !namePath.isJSXIdentifier() || namePath.node.name !== propName) {
          return;
        }
        const tagName = openingElement.get("name");
        const valuePath = path.get("value");
        if (!valuePath.isJSXExpressionContainer()) {
          return;
        }
        const expressionPath = valuePath.get("expression");
        if (!expressionPath.isExpression()) {
          return;
        }
        replaceNodePath(expressionPath, namePath, importName, t, tagName);
      },
      ObjectProperty(path) {
        const keyPath = path.get("key");
        if (!keyPath.isIdentifier() || keyPath.node.name !== propName) {
          return;
        }
        const valuePath = path.get("value");
        if (!valuePath.isIdentifier() && !valuePath.isMemberExpression() && !valuePath.isArrayExpression() && !valuePath.isObjectExpression() && !valuePath.isArrowFunctionExpression() && !valuePath.isConditionalExpression() && !valuePath.isLogicalExpression()) {
          return;
        }
        const parentJsxCall = path.findParent((p) => p.isCallExpression());
        if (!parentJsxCall || !parentJsxCall.isCallExpression()) {
          return;
        }
        const callee = parentJsxCall.get("callee");
        if (!callee.isIdentifier() || !callee.node.name.includes("jsx")) {
          return;
        }
        const jsxElement = parentJsxCall.get("arguments")[0];
        replaceNodePath(valuePath, keyPath, importName, t, jsxElement);
      }
    }
  };
});

export { babelPlugin };
//# sourceMappingURL=sx-plugin.mjs.map
//# sourceMappingURL=sx-plugin.mjs.map