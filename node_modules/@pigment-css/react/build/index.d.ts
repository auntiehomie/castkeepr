import { T as ThemeArgs, b as CSSProperties, B as BaseDefaultProps, P as PolymorphicComponent, S as Substitute, c as CSSObject, C as CSSObjectNoCallback } from './theme-aDBfke1X.js';
export { a as Breakpoint, k as BreakpointOverrides, h as CSSOthersObject, i as CSSOthersObjectNoCallback, d as CSSPropertiesMultiValue, e as CSSPropertiesWithCallback, f as CSSPseudos, g as CSSPseudosNoCallback, N as NoInfer, j as PolymorphicComponentProps } from './theme-aDBfke1X.js';
import * as React from 'react';
import { S as SxProp } from './sx.d-Cr4VrsXR.js';
export { s as sx } from './sx.d-Cr4VrsXR.js';
import 'csstype';
import '@mui/types';

type Primitve$2 = string | null | undefined | boolean | number;

interface KeyframesObject {
  [key: string]: {
    [K in keyof CSSProperties]: CSSProperties[K] | Array<CSSProperties[K]>;
  };
}

type KeyframesArg = ((themeArgs: ThemeArgs) => KeyframesObject) | KeyframesObject;

interface Keyframes {
  /**
   * @returns {string} The generated keyframe name to be referenced.
   */
  (arg: TemplateStringsArray, ...templateArgs: Primitve$2[]): string;
  /**
   * @returns {string} The generated keyframe name to be referenced.
   */
  (arg: KeyframesArg): string;
}

declare const keyframes: Keyframes;

type Falsy = false | 0 | '' | null | undefined;

interface StyledVariants<Props extends BaseDefaultProps> {
  props: Partial<Props> | ((props: Props) => boolean);
  style: CSSObject<Props>;
}

type StyledCssArgument<Props extends BaseDefaultProps> = CSSObject<Props> & {
  variants?: Array<StyledVariants<Props>>;
};

type StyledCallback<Props extends BaseDefaultProps> = (
  buildArg: ThemeArgs,
) => StyledCssArgument<Props>;

type StyledArgument<Props extends BaseDefaultProps> =
  | StyledCssArgument<Props>
  | StyledCallback<Props>;

interface StyledComponent<Props extends BaseDefaultProps = BaseDefaultProps>
  extends PolymorphicComponent<SxProp, Props> {
  defaultProps?: Partial<Props> | undefined;
  toString: () => string;
}

interface CreateStyledComponent<
  Component extends React.ElementType,
  OuterProps extends object,
> {
  // Template Literal case
  (
    styles: TemplateStringsArray,
    ...args: Array<
      | ((options: ThemeArgs) => Primitve$2)
      | Primitve$2
      | React.ComponentClass
      | StyledArgument<OuterProps>
    >
  ): StyledComponent<OuterProps> & (Component extends string ? BaseDefaultProps : Component);

  /**
   * @typeparam Props: Additional props to add to the styled component
   */
  <Props extends BaseDefaultProps = BaseDefaultProps>(
    ...styles: Array<StyledArgument<OuterProps & Props>>
  ): StyledComponent<Substitute<OuterProps, Props>> &
    (Component extends string ? BaseDefaultProps : Component);
}

interface StyledOptions<Props extends BaseDefaultProps = BaseDefaultProps> {
  name?: string;
  slot?: string;
  skipSx?: boolean;
  skipVariantsResolver?: boolean;
  shouldForwardProp?: (propName: string) => boolean;
  overridesResolver?: (
    props: any | Props,
    styles: Record<string, string>,
  ) => (string | Falsy) | Array<string | Falsy>;
}

interface CreateStyled {
  <
    TagOrComponent extends React.ElementType,
    FinalProps extends BaseDefaultProps = React.ComponentPropsWithRef<TagOrComponent>,
  >(
    tag: TagOrComponent,
    options?: StyledOptions,
  ): CreateStyledComponent<TagOrComponent, FinalProps>;
}

type CreateStyledIndex = {
  [Key in keyof React.JSX.IntrinsicElements]: CreateStyledComponent<
    Key,
    React.JSX.IntrinsicElements[Key]
  >;
};

declare const styled: CreateStyled & CreateStyledIndex;

// @TODO Implement proper types
type GenerateAtomicsResult = (props: any) => { className: string };

type AtomicProperty = {
  [Key in keyof CSSProperties]: ReadonlyArray<CSSProperties[Key]>;
};

type Atomics<
  Conditions extends Record<string, string>,
  Properties extends AtomicProperty = AtomicProperty,
  Shorthands extends Record<string, Array<keyof Properties>> = Record<
    string,
    Array<keyof Properties>
  >,
> = {
  conditions: Conditions;
  defaultCondition: keyof Conditions;
  properties: Properties;
  shorthands?: Shorthands;
};

declare function generateAtomics<Conditions extends Record<string, string>>(
  atomics: Atomics<Conditions> | ((themeConfig: ThemeArgs) => Atomics<Conditions>),
): GenerateAtomicsResult;

declare function atomics(config: unknown): string;

type Primitve$1 = string | null | undefined | boolean | number;

type CssArg$1 = ((themeArgs: ThemeArgs) => CSSObjectNoCallback) | CSSObjectNoCallback;
type CssFn$1 = (themeArgs: ThemeArgs) => string | number;

interface Css {
  /**
   * @returns {string} The generated css class name to be referenced.
   */
  (arg: TemplateStringsArray, ...templateArgs: (Primitve$1 | CssFn$1)[]): string;
  /**
   * @returns {string} The generated css class name to be referenced.
   */
  (...arg: CssArg$1[]): string;
}

declare const css: Css;

interface UseThemeProps {
  <Props>(params: { theme: Record<string, any>; props: Props; name: string }): Props;
}

declare function createUseThemeProps(theme: any): UseThemeProps;

declare function createExtendSxProp(): <T extends Record<string, any>>(props: T) => T;

declare function useTheme(): ThemeArgs extends { theme: unknown } ? ThemeArgs['theme'] : any;

type Primitve = string | null | undefined | boolean | number;

type CssArg = ((themeArgs: ThemeArgs) => CSSObjectNoCallback) | CSSObjectNoCallback;
type CssFn = (themeArgs: ThemeArgs) => string | number;

interface GlobalCss {
  /**
   * @returns {string} The generated css class name to be referenced.
   */
  (arg: TemplateStringsArray, ...templateArgs: (Primitve | CssFn)[]): string;
  /**
   * @returns {string} The generated css class name to be referenced.
   */
  (...arg: CssArg[]): string;
}

declare const globalCss: GlobalCss;

export { BaseDefaultProps, CSSObject, CSSObjectNoCallback, CSSProperties, PolymorphicComponent, type StyledComponent, Substitute, SxProp, atomics, createUseThemeProps, css, generateAtomics, globalCss, createExtendSxProp as internal_createExtendSxProp, keyframes, styled, useTheme };
