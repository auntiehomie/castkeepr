import { generateAtomics } from './chunk-N7I2UQMS.mjs';
import { __objRest, __spreadValues } from './chunk-L25ZX2YK.mjs';
import * as React from 'react';
import clsx from 'clsx';
import PropTypes from 'prop-types';
import { jsx } from 'react/jsx-runtime';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
var hiddenAtomics = generateAtomics(({ theme }) => {
  const conditions = {};
  for (let i = 0; i < theme.breakpoints.keys.length; i += 1) {
    const breakpoint = theme.breakpoints.keys[i];
    conditions[`${theme.breakpoints.keys[i]}Only`] = theme.breakpoints.only(breakpoint);
    conditions[`${theme.breakpoints.keys[i]}Up`] = theme.breakpoints.up(breakpoint);
    conditions[`${theme.breakpoints.keys[i]}Down`] = theme.breakpoints.down(breakpoint);
  }
  return {
    conditions,
    properties: {
      display: ["none"]
    }
  };
});
var Hidden = React.forwardRef(function Hidden2(_a, ref) {
  var _b = _a, { className, component = "div", style } = _b, props = __objRest(_b, ["className", "component", "style"]);
  const other = {};
  const breakpointProps = {};
  Object.keys(props).forEach((key) => {
    if (key.endsWith("Up") || key.endsWith("Down")) {
      breakpointProps[key] = "none";
    } else if (key === "only") {
      if (typeof props[key] === "string") {
        breakpointProps[`${props[key]}Only`] = "none";
      }
      if (Array.isArray(props[key])) {
        props[key].forEach((val) => {
          breakpointProps[`${val}Only`] = "none";
        });
      }
    } else {
      other[key] = props[key];
    }
  });
  const stackClasses = hiddenAtomics({ display: breakpointProps });
  const Component = component;
  return /* @__PURE__ */ jsx(
    Component,
    __spreadValues({
      ref,
      className: clsx(stackClasses.className, className),
      style: __spreadValues(__spreadValues({}, style), stackClasses.style)
    }, other)
  );
});
if (process.env.NODE_ENV !== "production") {
  Hidden.propTypes = {
    /**
     * The content of the component.
     */
    children: PropTypes.node,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes.elementType,
    /**
     * If `true`, screens this size and down are hidden.
     */
    lgDown: PropTypes.bool,
    /**
     * If `true`, screens this size and up are hidden.
     */
    lgUp: PropTypes.bool,
    /**
     * If `true`, screens this size and down are hidden.
     */
    mdDown: PropTypes.bool,
    /**
     * If `true`, screens this size and up are hidden.
     */
    mdUp: PropTypes.bool,
    /**
     * Hide the given breakpoint(s).
     */
    only: PropTypes.oneOfType([
      PropTypes.oneOf(["xs", "sm", "md", "lg", "xl"]),
      PropTypes.arrayOf(PropTypes.oneOf(["xs", "sm", "md", "lg", "xl"]))
    ]),
    /**
     * If `true`, screens this size and down are hidden.
     */
    smDown: PropTypes.bool,
    /**
     * If `true`, screens this size and up are hidden.
     */
    smUp: PropTypes.bool,
    /**
     * @ignore
     */
    style: PropTypes.object,
    /**
     * If `true`, screens this size and down are hidden.
     */
    xlDown: PropTypes.bool,
    /**
     * If `true`, screens this size and up are hidden.
     */
    xlUp: PropTypes.bool,
    /**
     * If `true`, screens this size and down are hidden.
     */
    xsDown: PropTypes.bool,
    /**
     * If `true`, screens this size and up are hidden.
     */
    xsUp: PropTypes.bool
  };
}
var Hidden_default = Hidden;

export { Hidden_default as default };
//# sourceMappingURL=Hidden.mjs.map
//# sourceMappingURL=Hidden.mjs.map