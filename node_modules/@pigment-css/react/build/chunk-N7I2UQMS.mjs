import cx from 'clsx';

/**
  * @pigment-css/react v0.0.30
  *
  * @license MIT
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
 
function generateAtomics() {
  if (typeof __wyw_dynamic_import !== "undefined") {
    return;
  }
  throw new Error(
    `${"@pigment-css/react"}: You were trying to call "generateAtomics" function without configuring your bundler. Make sure to install the bundler specific plugin and use it. @pigment-css/vite-plugin for Vite integration or @pigment-css/nextjs-plugin for Next.js integration.`
  );
}
function atomics({
  styles,
  shorthands,
  conditions,
  defaultCondition,
  unitless = [],
  multipliers = {},
  inlineGetters = {}
}) {
  function addStyles(cssProperty, propertyValue, classes, inlineStyle) {
    const styleClasses = styles[cssProperty];
    if (!styleClasses) {
      return;
    }
    function handlePrimitive(value, multiplier = void 0, inlineGetter = void 0, breakpoint = defaultCondition) {
      if (!(value in styleClasses)) {
        const keys = Object.keys(styleClasses);
        if (keys.length !== 1) {
          return;
        }
        const key = keys[0];
        let styleValue = value;
        if (typeof value === "number") {
          if (multiplier) {
            styleValue = `calc(${value} * ${multiplier})`;
          } else if (!unitless.includes(cssProperty)) {
            styleValue = `${value}px`;
          }
        }
        classes.push(styleClasses[key][breakpoint]);
        inlineStyle[`${key}-${breakpoint}`] = inlineGetter ? inlineGetter(styleValue) : styleValue;
      } else {
        classes.push(
          typeof styleClasses[value] !== "object" ? styleClasses[value] : styleClasses[value][breakpoint]
        );
      }
    }
    if (typeof propertyValue === "string" || typeof propertyValue === "number" || typeof propertyValue === "boolean") {
      handlePrimitive(propertyValue, multipliers[cssProperty], inlineGetters[cssProperty]);
    } else if (Array.isArray(propertyValue)) {
      propertyValue.forEach((value, index) => {
        if (value !== void 0 && value !== null) {
          const breakpoint = conditions[index];
          if (!breakpoint) {
            return;
          }
          handlePrimitive(
            value,
            multipliers[cssProperty],
            inlineGetters[cssProperty],
            conditions[index]
          );
        }
      });
    } else if (propertyValue) {
      Object.keys(propertyValue).forEach((condition) => {
        if (propertyValue[condition] !== void 0 && propertyValue[condition] !== null) {
          const propertyClasses = styleClasses[propertyValue[condition]];
          if (!propertyClasses) {
            handlePrimitive(
              propertyValue[condition],
              multipliers[cssProperty],
              inlineGetters[cssProperty],
              condition
            );
            return;
          }
          classes.push(propertyClasses[condition]);
        }
      });
    }
  }
  function generateClass(props) {
    const classes = [];
    const inlineStyle = {};
    Object.keys(props).forEach((cssProperty) => {
      const values = props[cssProperty];
      if (shorthands && cssProperty in shorthands) {
        const configShorthands = shorthands[cssProperty];
        if (!configShorthands) {
          return;
        }
        configShorthands.forEach((shorthand) => {
          addStyles(shorthand, values, classes, inlineStyle);
        });
      } else {
        addStyles(cssProperty, values, classes, inlineStyle);
      }
    });
    return {
      className: cx(Array.from(new Set(classes))),
      style: inlineStyle
    };
  }
  return generateClass;
}

export { atomics, generateAtomics };
//# sourceMappingURL=chunk-N7I2UQMS.mjs.map
//# sourceMappingURL=chunk-N7I2UQMS.mjs.map