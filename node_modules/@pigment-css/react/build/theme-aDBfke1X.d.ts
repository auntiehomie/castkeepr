import * as React from 'react';
import * as CSS from 'csstype';
import { OverridableStringUnion } from '@mui/types';

type CSSProperties = CSS.PropertiesFallback<number | string>;
type CSSPropertiesMultiValue = {
    [K in keyof CSSProperties]: CSSProperties[K] | Array<Extract<CSSProperties[K], string>>;
};
type CSSPropertiesWithCallback<Props extends object> = {
    [K in keyof CSSProperties]: CSSProperties[K] | Array<Extract<CSSProperties[K], string>> | ((props: Props) => CSSProperties[K]);
};
type CSSPseudos<Props extends object> = {
    [K in CSS.Pseudos]?: CSSObject<Props>;
};
type CSSPseudosNoCallback = {
    [K in CSS.Pseudos]?: CSSObjectNoCallback;
};
interface CSSOthersObject<Props extends object> {
    [selector: string]: CSSObject<Props>;
}
interface CSSOthersObjectNoCallback {
    [selector: string]: CSSObjectNoCallback;
}
type CSSObject<Props extends object> = CSSPropertiesWithCallback<Props> | CSSPseudos<Props> | CSSOthersObject<Props>;
type CSSObjectNoCallback = CSSPropertiesMultiValue | CSSPseudosNoCallback | CSSOthersObjectNoCallback;
type BaseDefaultProps = object;
type NoInfer<T> = [T][T extends any ? 0 : never];
type FastOmit<T extends object, U extends string | number | symbol> = {
    [K in keyof T as K extends U ? never : K]: T[K];
};
type Substitute<A extends object, B extends object> = FastOmit<A, keyof B> & B;
type PolymorphicComponentProps<SxProp, BaseProps extends object, AsTarget extends React.ElementType | undefined, AsTargetProps extends object = AsTarget extends React.ElementType ? React.ComponentPropsWithRef<AsTarget> : BaseDefaultProps> = NoInfer<Omit<Substitute<BaseProps, AsTargetProps>, 'as'>> & {
    as?: AsTarget;
    sx?: SxProp;
    children?: React.ReactNode;
};
interface PolymorphicComponent<SxProp, BaseProps extends BaseDefaultProps> extends React.ForwardRefExoticComponent<BaseProps> {
    <AsTarget extends React.ElementType | undefined = undefined>(props: PolymorphicComponentProps<SxProp, BaseProps, AsTarget>): React.JSX.Element;
}
interface BreakpointOverrides {
}
type Breakpoint = OverridableStringUnion<'xs' | 'sm' | 'md' | 'lg' | 'xl', BreakpointOverrides>;

interface ThemeInput<ColorScheme extends string = string> extends Record<string, any> {
    /**
     * The prefix to be used for the CSS variables.
     */
    cssVarPrefix?: string;
    /**
     * The color schemes to be used for the theme.
     */
    colorSchemes?: Record<ColorScheme, any>;
    /**
     * The default color scheme to be used for the theme. It must be one of the keys from `theme.colorSchemes`.
     * Required when `colorSchemes` is provided.
     * @default 'light'
     */
    defaultColorScheme?: ColorScheme;
    /**
     * If provided, it will be used to create a selector for the color scheme.
     * This is useful if you want to use class or data-* attributes to apply the color scheme.
     *
     * The callback receives the colorScheme with the possible values of:
     * - undefined: the selector for tokens that are not color scheme dependent
     * - string: the selector for the color scheme
     *
     * @example
     * // class selector
     * (colorScheme) => colorScheme !== 'light' ? `.theme-${colorScheme}` : ":root"
     *
     * @example
     * // data-* attribute selector
     * (colorScheme) => colorScheme !== 'light' ? `[data-theme="${colorScheme}"]` : ":root"
     */
    getSelector?: (colorScheme: ColorScheme | undefined, css: Record<string, any>) => string | Record<string, any>;
    /**
     * A function to skip generating a CSS variable for a specific path or value.
     *
     * Note: properties with function as a value are always skipped.
     *
     * @example
     * // skip the `meta.*` fields from generating CSS variables and `theme.vars`
     * (keys, value) => keys[0] === 'meta'
     *
     */
    shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean;
    components?: Partial<Record<string, {
        styleOverrides?: Record<string, any>;
        defaultProps: Record<string, any>;
    }>>;
}
type ExtendTheme<Options extends {
    colorScheme: string;
    tokens: Record<string, any>;
} = {
    colorScheme: string;
    tokens: Record<string, any>;
}> = ThemeInput<Options['colorScheme']> & Options['tokens'] & {
    vars: Options['tokens'];
    applyStyles: (colorScheme: Options['colorScheme'], styles: CSSObject<any>) => Record<string, CSSObject<any>>;
    getColorSchemeSelector: (colorScheme: Options['colorScheme']) => string;
    generateStyleSheets: () => Array<Record<string, any>>;
};

interface ThemeArgs {
}

export type { BaseDefaultProps as B, CSSObjectNoCallback as C, ExtendTheme as E, NoInfer as N, PolymorphicComponent as P, Substitute as S, ThemeArgs as T, Breakpoint as a, CSSProperties as b, CSSObject as c, CSSPropertiesMultiValue as d, CSSPropertiesWithCallback as e, CSSPseudos as f, CSSPseudosNoCallback as g, CSSOthersObject as h, CSSOthersObjectNoCallback as i, PolymorphicComponentProps as j, BreakpointOverrides as k };
